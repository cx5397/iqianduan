[{"categories":["css"],"content":"","date":"2022-07-27","img":"","permalink":"/posts/css/flex/","series":["flex"],"tags":["flex"],"title":"Css Flex"},{"categories":["对象"],"content":"日期格式化输出 1Date.prototype.format= function(fmt){ 2 var o={ 3 \u0026#39;y+\u0026#39;:this.getFullYear(), 4 \u0026#39;M+\u0026#39;:this.getMonth()+1, 5 \u0026#39;d+\u0026#39;:this.getDate(), 6 \u0026#39;h+\u0026#39;:this.getHours(), 7 \u0026#39;m+\u0026#39;:this.getMinutes(), 8 \u0026#39;s+\u0026#39;:this.getSeconds(), 9 \u0026#39;S\u0026#39;:this.getMilliseconds(),//毫秒 10 \u0026#39;q+\u0026#39;:Math.floor(this.getMonth()/3+1),//季度 11 }, 12 str=\u0026#39;\u0026#39;; 13 14 for(var k in o){ 15 if( new RegExp(\u0026#39;(\u0026#39;+k+\u0026#39;)\u0026#39;).test(fmt) ){ 16 str= (o[k]+\u0026#39;\u0026#39;).substr( -RegExp.$1.length ); 17 fmt=fmt.replace(RegExp.$1,str); 18 } 19 } 20 return fmt; 21} 日期对象初始化  new Date(year,month,day[,hour[,minutes[,seconds[,ms]]]]) new Date(datestr)  实例方法  [get|set][UTC?][FullYear|Month|Date|Hours|Minutes|Seconds|Milliseconds] //--2*2*7=28 getDay //星期几(0 星期日) [set|get]Time //时间戳 valueOf //1513930533133 getTimezoneOffset //-480 [set|get]Year toLocaleDateString //\u0026quot;2017/12/22\u0026quot; toLocaleString //\u0026quot;2017/12/22 下午4:12:32\u0026quot; toLocaleTimeString //\u0026quot;下午4:12:32\u0026quot;  静态方法(都是返回时间戳)  Date.now() Date.parse(datestr) Date.UTC(year,month,day[,hour[,minutes[,seconds[,ms]]]]) ","date":"2022-07-25","img":"","permalink":"/posts/objects/date/","series":["Date"],"tags":["Date"],"title":"Date"},{"categories":["对象"],"content":"概览  类的基本语法 类的继承 类的实例 es5 下的面向对象  类的基本语法  构造方法 实例属性 实例方法（普通 generator 方法 setter getter async）静态属性 静态方法 私有属性 私有方法  1class People { 2 constructor(name,age,sex) { 3 this.name = name; 4 this.age= age; 5 this.sex= sex; 6 } 7} 8//类里面的成员方法与属性都采用小驼峰 9class Boy extends People { 10 constructor(name,age) { 11 super(name,age,\u0026#39;男\u0026#39;); 12 } 13 14 /*私有属性与私有方法在属性或方法上加#,只能在类内部使用 私有属性和私有方法前面，也可以加上static关键字， 15 表示这是一个静态的私有属性或私有方法 私有只是提案，现有chrome已经实现，见1.1*/ 16 #a; 17 #b=3; 18 static #c= 4; 19 static #m(){} 20 #parseName(){ 21 return this.name.replace(/\\s/g,\u0026#39;\u0026#39;); 22 } 23 24 //实例属性的另外一种写法 一种是constructor中this.x 25 money; 26 money= 1000; 27 28 //静态属性 通过类访问 29 static maxAge= 120;//见1.2 30 31 //getter 32 get age(){ 33 retun this.age+1;//见1.4 34 } 35 //setter 36 set age(value){ 37 this.age= Math.floor(value); 38 //setter方法在对象中(非类)需要注意 可能内存溢出，见1.3 39 } 40 41 //静态方法 不能访问实例属性与方法 42 static getMaxAge(){ 43 return Boy.maxAge; 44 } 45 getAge(){ 46 return this.age+this.#b; 47 } 48 49 //generator方法 50 *getName(){ 51 yield Promise.resolve(1); 52 yield Promise.resolve(2); 53 } 54 55 //异步函数 串行执行 比如获取了用户的银行余额 再去付款 56 async serial(){ 57 let b= await Promise.resolve(1);//返回值，不是promise 58 let c= await Promise.resolve(b); 59 return c; //返回promise包装 60 } 61 62 //静态方法 自我实现四舍五入 63 static round(value){ 64 if(typeof value ===\u0026#39;number\u0026#39;){ 65 return (Number.parseInt(value)+.5\u0026gt;value)?Number.parseInt(value):(Number.parseInt(value)+1) 66 }else{ 67 return 0; 68 } 69 } 70} 1//1.1 2class PrivateVar{ 3 #a=2; 4 b=3; 5 getA(){ 6 return this.#a; 7 } 8} 9var p1= new PrivateVar(); 10console.log(p1.#a);//报错 11console.log(p1.b);//3 12console.log(p1.getA());//2 1//1.2 2class Static1{ 3 static width= 200; 4 height= 100; 5 static getArea(){ 6 //错误写法 静态不能访问非静态属性 7 return Static1.width*this.height; 8 } 9 getMaxSide(){ 10 //非静态方法可以访问静态属性 11 return Math.max(Static1.width,this.height); 12 } 13} 14let s1= new Static1(); 15s1.getMaxSide(); 16Static1.gettArea(); 17/*NaN (一个数字与undefined相加=NaN,null+数字=数字，字符串+数字=字符串拼接,true+1=2,false+1=1,对象+1=1) 18转化优先级undefined,null,boolean=\u0026gt;number=\u0026gt;string, 191.任何与字符串相加都是字符串 202.其它相加先转化为数字，undefined=》NaN,null=\u0026gt;0 213.NaN与其它数字相加等于NaN*/ 1//1.3 2let user = { 3 name: \u0026#39;xx\u0026#39;. 4 get name() { 5 return this.name; 6 }, 7 set name(value) { 8 this.name = value //这句话报错了 9 } 10}; 11user.name = \u0026#34;Peter\u0026#34;; //尝试赋值的时候报错Uncaught RangeError: Maximum call stack size exceeded 12//解决方法 13let user = { 14 _name:\u0026#39;xx\u0026#39;, 15 get name() { 16 return this._name; 17 }, 18 set name(value) { 19 this._name = value //设置一个中转变量 20 } 21}; 1//1.4 2class SetVar{ 3 m=2; 4 set m(d){this.m=d} 5} 6let d=new SetVar(); 7d.m=99;//{m:99}  类方法之间不需要逗号分隔，加了会报错 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。  1class Point { 2 constructor(x, y) { 3 // ... 4 } 5 toString() { 6 // ... 7 } 8} 9Object.keys(Point.prototype)// []  类与模块为严格模式，不需要声明 use strict; 类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。  1function m(){console.log(new.target===m)} 2m()//false 3new m()// true 通过这个可以强制函数通过new来调用  类不存在变量提升（hoist），这一点与 ES5 完全不同。  1new Foo(); // ReferenceError 2class Foo {}  方法多层嵌套，this 指向问题解决  11.箭头函数 22.重新赋值 如 let _t= this; 33.绑定this指向 4class Logger { 5 constructor() { 6 this.printName = this.printName.bind(this); 7 } 8 // ... 9}  类名采用大驼峰命名(单词首字母大写)  类的继承  类继承使用 extends 关键字 super() 可以调用父类的构造方法(可以传递非默认参数) 如果没有显式指定构造方法，则会添加默认的 constructor 方法。不显式调用会默认调用父类的构造方法  1基类默认构造方法 2constructor() {} 3派生类，默认构造函数 4constructor(...args) { 5 super(...args); 6} 7//------- 8class A {constructor(a){this.a=a;}}; 9class B extends A{} 10new B(1)//{a:1}  派生类可以继承父类的属性与方法  类的实例化  调用 new 类名(参数a,b...)，实际执行 constructor 构造方法，接收参数，实例化一个实例对象 类的所有实例共享一个原型对象 类名.prototype 继承与覆盖  1class A { 2 x=1; 3 y(){} 4 z(){console.log(\u0026#39;a\u0026#39;)} 5} 6class B extends A{ 7 constructor(a){if(a){this.m=a;}} 8 m=2; 9 z(){console.log(\u0026#39;b\u0026#39;)} 10} 11let p= new B(9);//m值=9; 12p.z();//\u0026#39;b\u0026#39; 覆盖了父类的z方法 13let p1= new B();// m值=2 es5 下的面向对象  生成实例对象的传统方法是通过构造函数 ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到， 新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已  1function Point(x, y) { 2 this.x = x; 3 this.y = y; 4} 5 6Point.prototype.toString = function () { 7 return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; 8}; 9 10var p = new Point(1, 2);  ES6 的类，完全可以看作构造函数的另一种写法。  1class Point { 2 // ... 3} 4 5typeof Point // \u0026#34;function\u0026#34; 类的数据类型就是函数 6Point === Point.prototype.constructor // true 类本身就指向构造函数  类有 prototype 和proto ,对象实例只有proto  1function Foo(){} 2let p= new Foo(); 3/* 4p.__proto__===\u0026gt;Foo.prototype(其__proto__===\u0026gt;Object.prototype(其__proto__===\u0026gt;null)) 5Foo.prototype,Object.prototype,Function.prototype都是由构造函数创建的 6自定义构造方法的__proto__=\u0026gt;Function.prototype(其__proto__==\u0026gt;Object.prototype) 7见github 图 8*/ ","date":"2022-07-25","img":"","permalink":"/posts/objects/class/","series":["Class"],"tags":["Class"],"title":"Class"},{"categories":["对象"],"content":"触发自定义事件 1var elem = document.querySelector(\u0026#39;#div\u0026#39;); 2var ev = new Event(\u0026#34;myEvent\u0026#34;, {\u0026#34;bubbles\u0026#34;:true, \u0026#34;cancelable\u0026#34;:false,composed:false}); 3//\u0026#34;bubbles\u0026#34;，可选，Boolean类型，默认值为 false，表示该事件是否冒泡。 4//\u0026#34;cancelable\u0026#34;，可选，Boolean类型，默认值为 false， 表示该事件能否被取消。 5//\u0026#34;composed\u0026#34;，可选，Boolean类型，默认值为 false，指示事件是否会在影子DOM根节点之外触发侦听器。 6 7// 监听myEvent 8elem.addEventListener(\u0026#39;myEvent\u0026#39;, function (e) { 9 console.log(e); 10}, false); 11 12// 使用目标对象去派发事件，可以是元素节点/事件对象 13elem.dispatchEvent(ev); 触发 resize 事件 1//向window派发resize事件 2window.dispatchEvent(new Event(\u0026#39;resize\u0026#39;)) ","date":"2022-07-25","img":"","permalink":"/posts/objects/event/","series":["Event"],"tags":["Event"],"title":"Event"},{"categories":["对象"],"content":"概览    类型 用途 属性 方法 遍历     Set 值不重复 size add delete has clear yes   WeakSet 值不重复,且为对象,且垃圾回收不考虑此引用 no add delete has no   Map 键可以为对象 size [set get]delete has clear yes   WeakMap 键为对象,且垃圾回收不考虑此引用 no [set get] delete has no    weak 表示弱引用 垃圾回收不考虑此引用,不可遍历,没有大小(WeakMap)键或(WeakSet)值需要是对象\nSet 不重复的值  成员不会有重复值  1let p= new Set([1,1])//1  Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化  1const set = new Set([1, 2, 3, 4, 4]); 2const set = new Set(document.querySelectorAll(\u0026#39;div\u0026#39;));  在 Set 中两个 NaN 是相等的,不同于其它,因此 Set 中 NaN 只能存在一个  1let set = new Set(); 2let a = NaN; 3let b = NaN; 4set.add(a); 5set.add(b); 6set // Set {NaN} 7 8NaN===NaN //false  Set 常常用来数组/字符串去重  1[...new Set(array)] 2[...new Set(\u0026#39;ababbc\u0026#39;)].join(\u0026#39;\u0026#39;)  Set 有实例属性 size,方法 add delete has clear  1let s= new Set([1]) 2s.add(2) 3s.size // 2 4s.has(1) // true 5s.delete(2);  Set 转换成数组 Array.from(aset)或 [\u0026hellip;aset]; Set 遍历方法有 keys=values(因为只有值没有键) entries forEach,默认为 values(可以 for(lex x of aset){})  1let set = new Set([\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]); 2for (let item of set.keys()) { 3 console.log(item); 4} 5// red green blue 6 7for (let item of set.entries()) { 8 console.log(item); 9} 10// [\u0026#34;red\u0026#34;, \u0026#34;red\u0026#34;] 11// [\u0026#34;green\u0026#34;, \u0026#34;green\u0026#34;] 12// [\u0026#34;blue\u0026#34;, \u0026#34;blue\u0026#34;] WeakSet 不重复的值, 弱引用, 只能放置对象, 没有 size 属性,也没办法遍历  只能放对象  1const b = [3, 4]; 2const ws = new WeakSet(b); 3// Uncaught TypeError: Invalid value used in weak set(…)  有三个实例方法 add delete has (比 Set 少了 clear),没有 size 属性,也没办法遍历 WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏  Map 可以对象作为键  创建一个 Map 实例  1const map = new Map([ 2 [\u0026#39;name\u0026#39;, \u0026#39;a\u0026#39;], 3 [\u0026#39;title\u0026#39;, \u0026#39;b\u0026#39;] 4]);  如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等,布尔值 true 和字符串 true 则是两个不同的键  1{true:1,\u0026#39;true\u0026#39;:2}//{\u0026#39;true\u0026#39;:2} 2 3let map = new Map(); 4map.set(true, 1); 5map.set(\u0026#39;true\u0026#39;, 2); 6map.get(true) // 1 7map.get(\u0026#39;true\u0026#39;) // 2  实例属性 size,实例方法 set get has delete clear  1let map= new Map() 2map.set(1,1); 3map.get(1);//1 4map.has(1);//true 是否有某个键 5map.size//1 6map.delete(1)//true 成功true 失败false 7map.clear()//除所有成员，没有返回值 8  遍历方法 keys values entries forEach (遍历顺序就是插入顺序), 默认遍历器接口 entries(for (let [key, value] of map) {})  1for (let key of map.keys()) { 2 console.log(key); 3} 4for (let item of map.entries()) { 5 console.log(item[0], item[1]); 6} 7或者解构赋值 8for (let [key, value] of map.entries()) { 9 console.log(key, value); 10} 11或者默认遍历器 12for (let [key, value] of map) { 13 console.log(key, value); 14}  Map 转为数组 [\u0026hellip;amap]  1const myMap = new Map() 2 .set(true, 7) 3 .set({foo: 3}, [\u0026#39;abc\u0026#39;]); 4[...myMap] 5// [ [ true, 7 ], [ { foo: 3 }, [ \u0026#39;abc\u0026#39; ] ] ] WeakMap 只接受对象作为键名（null 除外）,键名弱引用, 不可遍历, 没有 size 属性  DOM 节点作为键名  1//一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 2let myElement = document.getElementById(\u0026#39;logo\u0026#39;); 3let myWeakmap = new WeakMap(); 4myWeakmap.set(myElement, {timesClicked: 0}); 5 6myElement.addEventListener(\u0026#39;click\u0026#39;, function() { 7 let logoData = myWeakmap.get(myElement); 8 logoData.timesClicked++; 9}, false);  部署私有属性  1const _counter = new WeakMap(); 2class Countdown { 3 constructor(counter, action) { 4 //内部属性_counter，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏 5 _counter.set(this, counter); 6 } 7 dec() { 8 let counter = _counter.get(this); 9 if (counter \u0026lt; 1) return; 10 counter--; 11 _counter.set(this, counter); 12 } 13} ","date":"2022-07-25","img":"","permalink":"/posts/objects/mapset/","series":["Map\u0026Set"],"tags":["Map\u0026Set"],"title":"Map\u0026Set"},{"categories":["对象"],"content":"模块 commonjs amd cmd umd es6  commonjs nodejs 模块规范 语法有 require() exports.a=b; exports.default={}  1// foobar.js 2 3//私有变量 4var test = 123; 5 6//公有方法 7function foobar () { 8 9 this.foo = function () { 10 // do someing ... 11 } 12 this.bar = function () { 13 //do someing ... 14 } 15} 16 17//exports对象上的方法和变量是公有的 18var foobar = new foobar(); 19exports.foobar = foobar; 1//require方法默认读取js文件，所以可以省略js后缀 2var test = require(\u0026#39;./boobar\u0026#39;).foobar; 3 4test.bar();  amd: Asynchronous Module Definition 异步模块定义 推崇依赖前置 相关实现库 requirejs，语法 define(id?, dependencies?, factory) cmd: Common Module Definition 推崇依赖就近 类似 amd 相关实现库 seajs  1//AMD 2define([\u0026#39;./a\u0026#39;,\u0026#39;./b\u0026#39;], function (a, b) { 3 4 //依赖一开始就写好 5 a.test(); 6 b.test(); 7}); 8 9//CMD 10define(function (requie, exports, module) { 11 12 //依赖可以就近书写 13 var a = require(\u0026#39;./a\u0026#39;); 14 a.test(); 15 16 ... 17 //软依赖 18 if (status) { 19 20 var b = requie(\u0026#39;./b\u0026#39;); 21 b.test(); 22 } 23});  umd Universal Module Definition 通用模块定义,是 AMD 和 CommonJS 的糅合 UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 Node.js 模块模式。在判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块  1(function (window, factory) { 2 if (typeof exports === \u0026#39;object\u0026#39;) { 3 4 module.exports = factory(); 5 } else if (typeof define === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; define.amd) { 6 7 define(factory); 8 } else { 9 10 window.eventUtil = factory(); 11 } 12})(this, function () { 13 // module ... 14});  ES6：语言标准的模块化，取代 UMD，服务器和浏览器都能使用  es6 模块导入与导出    操作 语法 重命名 对应导入 对应导入重命名     直接导出 export var a=2;or export function a(){}; no import {a} from 'x'; import {a as b} from 'x';   先申明,再导出 var a=2,b=3;export {a,b};or function a(){};export {a}; export {a as c,b}; import {a,b} from 'x'; import {a as c,b} from 'x';   默认导出 export default function(){};or export default 44; 不需要 import a from 'x'; 不需要   先申明,再默认导出 function a(){};export default a;or var a=2;export default a; 不需要 import a from 'x'; 不需要     总结： 默认导入导出不需要重命名,因为导入的名字可以随便取;非默认导入导出 {}里都支持重命名  export import 复合写法  如果在一个模块之中，先输入后输出同一个模块，import 语句可以与 export 语句写在一起  1export { foo, bar } from \u0026#39;foo\u0026#39;;//导出foo中的foo bar 2export { default } from \u0026#39;foo\u0026#39;;//导出foo中的默认输出 3export * from \u0026#39;foo\u0026#39;;//export *命令会忽略foo模块的default方法  注意：import 和 export 命令只能在模块的顶层，不能在代码块之中，JavaScript 引擎静态分析，先于模块内的其他语句执行。 ","date":"2022-07-25","img":"","permalink":"/posts/objects/module/","series":["Module"],"tags":["Module"],"title":"Module"},{"categories":["对象"],"content":"number 转字符串 toString(n) 1function generateRandomAlphaNum(len) { 2 var rdmString = \u0026#34;\u0026#34;; 3 for (; rdmString.length \u0026lt; len; rdmString += Math.random().toString(36).substr(2)); 4 return rdmString.substr(0, len); 5}//\u0026#34;kallkv6nte\u0026#34; 常用属性  Number.MAX_VALUE Number.MIN_VALUE Number.MAX_SAFE_INTERGER Number.MIN_SAFE_INTERGER Number.NaN  常用方法  Number.isFinite() Number.isInteger() Number.isNaN() Number.isSafeInteger() Number.parseFloat() Number.parseInt() Number.prototype.toExponential()幂 Number.prototype.toFixed()小数位 Number.prototype.toLocaleString() 格式化默认加千分位 Number.prototype.toPrecision() 有效数位数 Number.prototype.toString() ","date":"2022-07-25","img":"","permalink":"/posts/objects/number/","series":["Number"],"tags":["Number"],"title":"Number"},{"categories":["对象"],"content":"用新对象 Reflect 代替 Object 部分静态方法与 function 的 apply 方法  1.原因4点,见http://es6.ruanyifeng.com/#docs/reflect 2.Reflect方法有13个 Reflect.apply(target,thisArg,args) Reflect.construct(target,args) Reflect.get(target,name,receiver) Reflect.set(target,name,value,receiver) ---属性--- Reflect.defineProperty(target,name,desc)//configurable enumerable writable value Reflect.deleteProperty(target,name) Reflect.has(target,name) Reflect.ownKeys(target)//自身可枚举不可枚举属性 Reflect.getOwnPropertyDescriptor(target, name) Reflect.isExtensible(target) Reflect.preventExtensions(target)//不能添加新属性 ---原型--- Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) 3.Object剩余静态方法10个 Object.assign()//复制对象 Object.create() Object.is()//判断两个值是否相等，大致等于===,两点区别(+0，-0不相等;NaN，NaN相等) Object.freeze()//冰冻对象,只能查询属性值 Object.isFrozen() Object.seal()//密封对象,只可以修改(仅仅是值),查询已有属性的值。 Object.isSealed() Object.keys()//自身可枚举属性 Object.values()//自身可枚举属性的值 Object.entries()//自身可枚举属性的[[key,value],...] 备注:Object的实例方法有四个,mdn还有其它5个(3个非标准，2个极少用) Object.prototype.hasOwnProperty() Object.prototype.isPrototypeOf() Object.prototype.propertyIsEnumerable() Object.prototype.toString()  preventExtensions seal freeze 区别    function add property delete property modify property value configurable enumerable writable prototype modify     freeze(啥都不能干了) × × × × ×   seal(只能修改属性值) × × √ × ×   preventExtensions(不能添加新值) × √ √ √ ×   ","date":"2022-07-25","img":"","permalink":"/posts/objects/reflectproxy/","series":["Reflect\u0026Proxy"],"tags":["Reflect\u0026Proxy"],"title":"Reflect\u0026Proxy"},{"categories":["vue"],"content":"槽 组件中定义一个槽 1//navigation-link组件 2//插槽内可以包含任何模板代码 3//\u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; 将会被替换为1.1中的 \u0026lt;span class=\u0026#34;fa fa-user\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Your Profile 4\u0026lt;a 5 v-bind:href=\u0026#34;url\u0026#34; 6 class=\u0026#34;nav-link\u0026#34; 7\u0026gt; 8 \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; 9\u0026lt;/a\u0026gt; 10 后备内容 1//Submit只会在没有提供内容的时候被渲染 2\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt; 3 \u0026lt;slot\u0026gt;Submit\u0026lt;/slot\u0026gt; 4\u0026lt;/button\u0026gt; 具名槽 1//一个不带 name 的 \u0026lt;slot\u0026gt; 出口会带有隐含的名字“default” 2\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; 3 \u0026lt;header\u0026gt; 4 \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; 5 \u0026lt;/header\u0026gt; 6 \u0026lt;main\u0026gt; 7 \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; 8 \u0026lt;/main\u0026gt; 9 \u0026lt;footer\u0026gt; 10 \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; 11 \u0026lt;/footer\u0026gt; 12\u0026lt;/div\u0026gt; 带数据的槽 1\u0026lt;span\u0026gt; 2 \u0026lt;slot v-bind:user=\u0026#34;user\u0026#34;\u0026gt; 3 {{ user.lastName }}//默认 4 \u0026lt;/slot\u0026gt; 5\u0026lt;/span\u0026gt; 插 插入槽内容 1//1.1 2 3\u0026lt;navigation-link url=\u0026#34;/profile\u0026#34;\u0026gt; 4 \u0026lt;!-- 添加一个 Font Awesome 图标 --\u0026gt; 5 \u0026lt;span class=\u0026#34;fa fa-user\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 6 Your Profile 7\u0026lt;/navigation-link\u0026gt; 8 具名插  注意 v-slot、#只能够用在 template 或者组件上  1//\u0026lt;template\u0026gt; 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 v-slot 的 \u0026lt;template\u0026gt; 中的内容都会被视为默认插槽的内容 2\u0026lt;base-layout\u0026gt; 3 \u0026lt;template v-slot:header\u0026gt; 4 \u0026lt;h1\u0026gt;Here might be a page title\u0026lt;/h1\u0026gt; 5 \u0026lt;/template\u0026gt; 6 7 \u0026lt;template v-slot:default\u0026gt; 8 \u0026lt;p\u0026gt;A paragraph for the main content.\u0026lt;/p\u0026gt; 9 \u0026lt;p\u0026gt;And another one.\u0026lt;/p\u0026gt; 10 \u0026lt;/template\u0026gt; 11 12 \u0026lt;template v-slot:footer\u0026gt; 13 \u0026lt;p\u0026gt;Here\u0026#39;s some contact info\u0026lt;/p\u0026gt; 14 \u0026lt;/template\u0026gt; 15\u0026lt;/base-layout\u0026gt; 插入带数据的槽 1\u0026lt;current-user\u0026gt; 2 \u0026lt;template v-slot:default=\u0026#34;slotProps\u0026#34;\u0026gt; 3 {{ slotProps.user.firstName }} 4 \u0026lt;/template\u0026gt; 5\u0026lt;/current-user\u0026gt; 缩写 1参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header ","date":"2022-07-25","img":"","permalink":"/posts/vue/slot/","series":["slot"],"tags":["slot"],"title":"Slot"},{"categories":["工具"],"content":"vscode 插件  Prettier - Code formatter vetur  settings.json 重要配置(文件-首选项-设置) 1\u0026#34;editor.formatOnSave\u0026#34;: true, //按保存键时触发格式化 2\u0026#34;files.autoSave\u0026#34;: \u0026#34;off\u0026#34;,//不自动保存，按保存键触发格式化 3\u0026#34;eslint.alwaysShowStatus\u0026#34;: true,//编辑器下面显示eslint的状态栏，!!!如果显示禁用要点击下开启，不开启eslint编辑器不报错提醒 4//语言格式化配置，分多条写如[javascript]:{} 5\u0026#34;[javascript|vue|html|typescript|html|scss|css]\u0026#34;: { 6 \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; 7}, vscode 设置  编辑窗口右键 format document with\u0026hellip; configure default formatter 选中 prettier  package.json 相关包  \u0026ldquo;@vue/cli-plugin-babel\u0026rdquo;: \u0026ldquo;^4.4.0\u0026rdquo;, //cli 工具初始化自带 \u0026ldquo;@vue/cli-plugin-eslint\u0026rdquo;: \u0026ldquo;~4.5.0\u0026rdquo;, //cli 工具初始化自带 \u0026ldquo;babel-eslint\u0026rdquo;: \u0026ldquo;^10.1.0\u0026rdquo;, //cli 工具初始化自带 \u0026ldquo;eslint\u0026rdquo;: \u0026ldquo;^6.7.2\u0026rdquo;, //cli 工具初始化自带 \u0026ldquo;eslint-plugin-vue\u0026rdquo;: \u0026ldquo;^6.2.2\u0026rdquo;, //cli 工具初始化自带 \u0026ldquo;eslint-config-prettier\u0026rdquo;: \u0026ldquo;^6.12.0\u0026rdquo;, \u0026ldquo;eslint-plugin-prettier\u0026rdquo;: \u0026ldquo;^3.1.4\u0026rdquo;  规则配置  eslint(语法规则检测)见 .eslintrc.js (在rules:{'prettier/prettier': 'error'}开启 prettier) prettier(代码格式化)见 .prettierrc.js  .eslintrc.js 参考 1module.exports = { 2 root: true, 3 parserOptions: { 4 parser: \u0026#39;babel-eslint\u0026#39; 5 }, 6 env: { 7 browser: true, 8 es6: true, 9 node: true 10 }, 11 extends: [ 12 \u0026#39;plugin:vue/essential\u0026#39;, //https://eslint.vuejs.org/rules/ 13 \u0026#39;eslint:recommended\u0026#39;, //https://eslint.bootcss.com/docs/rules/ 14 \u0026#39;plugin:prettier/recommended\u0026#39; 15 ], 16 // required to lint *.vue files 17 plugins: [\u0026#39;vue\u0026#39;], 18 // add your custom rules here 19 rules: { 20 \u0026#39;prettier/prettier\u0026#39;: \u0026#39;error\u0026#39;, 21 \u0026#39;no-unused-vars\u0026#39;: \u0026#39;error\u0026#39;, 22 \u0026#39;no-console\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;warn\u0026#39; : \u0026#39;off\u0026#39;, 23 \u0026#39;no-debugger\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;warn\u0026#39; : \u0026#39;off\u0026#39; 24 } 25}; 26 .prettierrc.js 参考 1module.exports = { 2 // tab缩进大小,默认为2 3 tabWidth: 4, 4 // 超过最大值换行 默认80(项目实践出结果) 5 printWidth: 120, 6 // 使用tab缩进，默认false 7 useTabs: false, 8 // 句尾添加分号 9 semi: true, 10 // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)(项目实践出结果) 11 singleQuote: true, 12 // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行 13 proseWrap: \u0026#39;preserve\u0026#39;, 14 // (x) =\u0026gt; {} 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 always 总是有括号 15 arrowParens: \u0026#39;always\u0026#39;, 16 // 在对象，数组括号与文字之间加空格 \u0026#34;{ foo: bar }\u0026#34; 17 bracketSpacing: true, 18 // 结尾是 \\n \\r \\n\\r auto 19 endOfLine: \u0026#39;auto\u0026#39;, 20 htmlWhitespaceSensitivity: \u0026#39;ignore\u0026#39;, 21 // 不使用prettier格式化的文件填写在项目的.prettierignore文件中 22 ignorePath: \u0026#39;.prettierignore\u0026#39;, 23 // Require a \u0026#34;prettierconfig\u0026#34; to format prettier 24 requireConfig: false, 25 // 行尾逗号,默认none,可选 none|es5|all {name: \u0026#39;audaque\u0026#39;} 26 // es5 包括es5中的数组、对象 27 // all 包括函数对象等所有可选 28 trailingComma: \u0026#39;none\u0026#39; 29}; 30 换行符 crlf、lf 处理  Ensure Prettier’s endOfLine option is set to lf (this is a default value since v2.0.0) 能够检查出来那里不是 lf，但是不能纠正 Configure a pre-commit hook that will run Prettier 提交前检查 Configure Prettier to run in your CI pipeline using \u0026ndash;check flag. If you use Travis CI, set the autocrlf option to input in .travis.yml. git config --global core.autocrlf input 能够在提交到 git 仓库转化为 lf，下载时不转化 Add * text=auto eol=lf to the repo’s .gitattributes file. You may need to ask Windows users to re-clone your repo after this change to ensure git has not converted LF to CRLF on checkout. 安装 vscode 插件 EditorConfig for VS Code ，配置.editorconfig ，保存时能够自动更正换行符  1[*] 2end_of_line = lf ","date":"2022-07-25","img":"","permalink":"/posts/tools/vscode/","series":["vscode"],"tags":["vscode"],"title":"Vscode"},{"categories":["浏览器"],"content":"console [nodejs 与浏览器共同部分]  error 错误 warn 警告 info 提示 log 日志 assert 断言 false 时输出 dir 目录样式输出对象的属性 trace 堆栈跟踪 time 执行时间分析console.time(\u0026quot;t1\u0026quot;);console.timeEnd(\u0026quot;t1\u0026quot;) timeEnd 重写 log，变颜色  1var _log = console.log; 2console.log = function() { 3 _log.call(console, \u0026#39;%c\u0026#39; + [].slice.call(arguments).join(\u0026#39; \u0026#39;), \u0026#39;color:transparent;text-shadow:0 0 2px rgba(0,0,0,.5);\u0026#39;); 4}; window 常用属性  window.devicePixelRatio window.document window.history window.location window.innerWidth window.innerHeight Window.localStorage window.navigator window.outerWidth window.outerHeight window.scrollX window.scrollY window.sessionStorage window.screen window.console  常用方法  window.scrollTo(x,y) window.scrollBy(x-add,y-add) window.print() window.confirm() window.alert() window.prompt(title-string) window.setTimeout()/clearTimeout window.setInterval()/clearInterval window.getSelection() 获取选择的文字对象  ajax 请求  var xhr = new XMLHttpRequest();//新建ajax请求，不兼容IE7以下 xhr.onreadystatechange = function(){//注册回调函数 if(xhr.readyState === 4){ success(xhr.responseText); } } xhr.open(method,url,true); xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xhr.send(JSON.stringify(data));//发送的数据需要转化成JSON格式  document 常用属性  首次获取 document.body, document.head, document.getElementById('id'), document.getElementsByClassName('classname'), document.getElementsByName('name'), document.getElementsByTagName('tagname'), document.querySelector('string'), document.querySelectorAll('string') 查父元素 node.parentNode 内容 ele.innerHTML ele.outerHTML ele.textContent 查兄弟元素 node.previousSibling, node.nextSibling，node.previousElementSibling, node.nextElementSibling 查子元素 node.childNodes(包含text与comment),node.children, node.firstChild, node.lastChild, (node.hasChildNodes()是否有子元素) 其它 document.charset document.cookie document.domain document.title document.images element 尺寸 内clientWidth clientHeight  外offsetWidth offsetHeight offsetTop offsetLeft  常用方法  属性 node.getAttribute(name) node.hasAttribute(name) node.removeAttribute(name) node.setAttribute(name,value) node.innerHTML classList cl.add(class) cl.remove(class) cl.toggle(class) cl.contains(class) 添加删除元素 node.appendChild(node2) node.removeChild(node2) node.replaceChild(被替换,node2) node.insertBefore(插入的,node2) 复制元素 cloneNode(bool) 是否包含字元素 el.contains(child) 创建元素 createElement(tag) createTextNode(text) createAttribute(attribute-name) document.execCommand(\u0026lsquo;commandname\u0026rsquo;) 如\u0026rsquo;copy\u0026rsquo;复制选中的文字 某个元素里面插入元素 ele.insertAdjacentHTML(position, text); adjacent:临近的 position:beforebegin [afterbegin beforeend afterend]  1\u0026lt;!-- beforebegin --\u0026gt; 2\u0026lt;p\u0026gt; 3 \u0026lt;!-- afterbegin --\u0026gt; 4 foo 5 \u0026lt;!-- beforeend --\u0026gt; 6\u0026lt;/p\u0026gt; 7\u0026lt;!-- afterend --\u0026gt; 浏览器返回效果  表单中的内容会保留 无论浏览器自带的返回前进按钮，还是history.go(-1)、history.back()...到新的页面代码都会重新执行一次 ","date":"2022-07-25","img":"","permalink":"/posts/browser/webapi/","series":["web api"],"tags":["web api"],"title":"Web Api"},{"categories":["对象"],"content":"Array  Array.of(a,b,c\u0026hellip;)代替 new Array(\u0026hellip;),因为new Array(3)//[undefined × 3];new Array(3,4)//[3,4] 除 let of 外,遍历:forEach(), filter(), every() 和 some() map(此结果包括空位)都会跳过空位,es6 规定空位被转化为 undefined，由于空位的处理规则非常不统一，所以建议避免出现空位(ff,chrome 将 delete 的位，间隔的位，视为空位，ie 将这些直接转化为 undefined，undefined 为空位)。  函数修改原始值的方法(9 个)    修改原始值的方法 函数返回值     Array.prototype.copyWithin 修改后数组   Array.prototype.fill 修改后数组   Array.prototype.pop 删除的元素   Array.prototype.push 数组长度   Array.prototype.shift 删除的元素   Array.prototype.unshift 数组长度   Array.prototype.sort 排序后新数组   Array.prototype.reverse 修改后数组   Array.prototype.splice 删除的元素组成的数组   ","date":"2022-07-25","img":"","permalink":"/posts/objects/array/","series":["Array"],"tags":["Array"],"title":"数组"},{"categories":["计算机基础"],"content":"策略模式  允许封装用于特定任务的备选算法的设计模式。它可以定义一系列算法，并以这样一种方式封装它们。它们在运行时可以互换调用顺序，而不需要编写额外的代码  1//策略列表 2const jobList = [\u0026#39;FE\u0026#39;, \u0026#39;BE\u0026#39;]; 3var strategies = { 4 checkRole: function(value) { 5 if (value === \u0026#39;registered\u0026#39;) { 6 return true; 7 } 8 return false; 9 }, 10 checkGrade: function(value) { 11 if (value \u0026gt;= 1) { 12 return true; 13 } 14 return false; 15 }, 16 checkJob: function(value) { 17 if (jobList.indexOf(value) \u0026gt; 1) { 18 return true; 19 } 20 return false; 21 }, 22 checkType: function(value) { 23 if (value === \u0026#39;active user\u0026#39;) { 24 return true; 25 } 26 return false; 27 } 28}; 29//验证逻辑 30var Validator = function() { 31 // Store strategies 32 this.cache = []; 33 // add strategy to cache 34 this.add = function(value, method) { 35 this.cache.push(function() { 36 return strategies[method](value); 37 }); 38 }; 39 // check all strategies 40 this.check = function() { 41 for (let i = 0; i \u0026lt; this.cache.length; i++) { 42 let valiFn = this.cache[i]; 43 var data = valiFn(); 44 if (!data) { 45 return false; 46 } 47 } 48 return true; 49 }; 50}; 51//调用 52var compose1 = function() { 53 var validator = new Validator(); 54 const data1 = { 55 role: \u0026#39;register\u0026#39;, 56 grade: 3, 57 job: \u0026#39;FE\u0026#39;, 58 type: \u0026#39;active user\u0026#39; 59 }; 60 validator.add(data1.role, \u0026#39;checkRole\u0026#39;); 61 validator.add(data1.grade, \u0026#39;checkGrade\u0026#39;); 62 validator.add(data1.type, \u0026#39;checkType\u0026#39;); 63 validator.add(data1.job, \u0026#39;checkJob\u0026#39;); 64 const result = validator.check(); 65 return result; 66}; 发布-订阅模式  一种消息传递范例，消息的发布者不直接将消息发送给特定的订阅者，而是通过消息通道广播消息，订阅者通过订阅获得他们想要的消息。  1const EventEmit = function() { 2 this.events = {}; 3 this.on = function(name, cb) { 4 if (this.events[name]) { 5 this.events[name].push(cb); 6 } else { 7 this.events[name] = [cb]; 8 } 9 }; 10 this.trigger = function(name, ...arg) { 11 if (this.events[name]) { 12 this.events[name].forEach(eventListener =\u0026gt; { 13 eventListener(...arg); 14 }); 15 } 16 }; 17}; 18 19let event = new EventEmit(); 20MessageCenter.fetch() { 21 event.on(\u0026#39;success\u0026#39;, () =\u0026gt; { 22 console.log(\u0026#39;update MessageCenter\u0026#39;); 23 }); 24} 25Order.update() { 26 event.on(\u0026#39;success\u0026#39;, () =\u0026gt; { 27 console.log(\u0026#39;update Order\u0026#39;); 28 }); 29} 30Checker.alert() { 31 event.on(\u0026#39;success\u0026#39;, () =\u0026gt; { 32 console.log(\u0026#39;Notify Checker\u0026#39;); 33 }); 34} 35event.trigger(\u0026#39;success\u0026#39;); 1//类似事件触发 2window.addEventListener(\u0026#39;event_name\u0026#39;, function(event){ 3 console.log(\u0026#39;得到标题为：\u0026#39;, event.detail.title); 4}); 5var myEvent = new CustomEvent(\u0026#39;event_name\u0026#39;, { 6 detail: { title: \u0026#39;This is title!\u0026#39;}, 7}); 8// 随后在对应的元素上触发该事件 9if(window.dispatchEvent) { 10 window.dispatchEvent(myEvent); 11} else { 12 window.fireEvent(myEvent); 13} 装饰者模式  种给对象动态地增加职责的方式称为装饰者（decorator）模式。装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式  1//原始对象 2// 建立一架飞机 3var Plane = function(){} 4// 飞机有发射普通子弹的方法 5Plane.prototype.fire = function(){ 6 console.log( \u0026#39;发射普通子弹\u0026#39; ); 7} 8 9 10//接下来增加两个装饰类，分别是导弹和原子弹： 11var MissileDecorator = function( plane ){ 12 this.plane = plane; 13} 14MissileDecorator.prototype.fire = function(){ 15 this.plane.fire(); 16 console.log( \u0026#39;发射导弹\u0026#39; ); 17} 18var AtomDecorator = function( plane ){ 19 this.plane = plane; 20} 21AtomDecorator.prototype.fire = function(){ 22 this.plane.fire(); 23 console.log( \u0026#39;发射原子弹\u0026#39; ); 24} 25 26//调用 27var plane = new Plane(); 28plane = new MissileDecorator( plane ); 29plane = new AtomDecorator( plane ); 30plane.fire(); 31// 分别输出： 发射普通子弹、发射导弹、发射原子弹 责任链模式  为请求创建了一个接收者对象的链。多个对象均有机会处理请求，从而解除发送者和接受者之间的耦合关系。这些对象连接成为“链式结构”，每个节点转发请求，直到有对象处理请求为止  1 class Handler { 2 constructor() { 3 this.handler = null; 4 } 5 // 将下一个需要处理的操作缓存起来 6 setNextHandler(handler) { 7 this.next = handler; 8 } 9 } 10 11 class LogHandler extends Handler { 12 constructor() { 13 super(); 14 this.name = \u0026#39;log\u0026#39;; 15 } 16 17 handle(type, msg) { 18 if (type == this.name) { 19 console.log(`${type} ---------- ${msg}`); 20 return; 21 } 22 // 假如下一个处理操作存在就继续往下处理，走到这里表示当前并非终点 23 this.next \u0026amp;\u0026amp; this.next.handle(...arguments); 24 } 25 } 26 27 class WarnHandler extends Handler { 28 constructor() { 29 super(); 30 this.name = \u0026#39;warn\u0026#39;; 31 } 32 33 handle(type, msg) { 34 if (type == this.name) { 35 //假如传过来的类型与名字相同， 说明是当前操作处理 36 console.log(`${type} ---------- ${msg}`); 37 return; 38 } 39 // 假如下一个处理操作存在就继续往下处理，走到这里表示当前并非终点 40 this.next \u0026amp;\u0026amp; this.next.handle(...arguments); 41 } 42 } 43 44 class ErrorHandler extends Handler { 45 constructor() { 46 super(); 47 this.name = \u0026#39;error\u0026#39;; 48 } 49 50 handle(type, msg) { 51 if (type == this.name) { 52 console.log(`${type} ---------- ${msg}`); 53 return; 54 } 55 // 假如下一个处理操作存在就继续往下处理，走到这里表示当前并非终点 56 this.next \u0026amp;\u0026amp; this.next.handle(...arguments); 57 } 58 } 59 60 const logHandler = new LogHandler(); 61 const warnHandler = new WarnHandler(); 62 const errorHandler = new ErrorHandler(); 63 64 //设置下一个处理的节点 65 logHandler.setNextHandler(warnHandler); 66 warnHandler.setNextHandler(errorHandler); 67 68 // 开始依次处理满足条件的日志 69 logHandler.handle(\u0026#39;log\u0026#39;, \u0026#39;this is some logs!\u0026#39;); // log ---------- this is some logs! 70 logHandler.handle(\u0026#39;warn\u0026#39;, \u0026#39;this is some warnings!\u0026#39;); // warn ---------- this is some warnings! 71 logHandler.handle(\u0026#39;error\u0026#39;, \u0026#39;this is some errors!\u0026#39;); // error ---------- this is some errors! ","date":"2022-07-25","img":"","permalink":"/posts/computer/designmode/","series":["编码"],"tags":["设计模式"],"title":"设计模式"},{"categories":["计算机基础"],"content":"base64 加解密 1var enc = window.btoa(str) //编码成base64的 2var dec = window.atob(enc) //把base64解码 3 4//中文需要先编码 还可以解码回来 5var str = btoa(encodeURIComponent(\u0026#34;中文汉字\u0026#34;)); 6decodeURIComponent(atob(enc)) =\u0026gt; 中文汉字 md5 散列值，用于鉴别传输值是否被篡改(md5.js) 1var b =$(\u0026#34;#logPassword\u0026#34;); 2$.md5(b.val()) 3 4//两次md5 加盐 5console.log(md5(md5(\u0026#34;Condor Hero\u0026#34;) + \u0026#34;a\u0026#34;)); sha1 散列值，用于鉴别传输值是否被篡改，比 md5 强且慢(sha1.js) 1var sha = hex_sha1(\u0026#39;mima123465\u0026#39;); 2console.log(sha); RSA 用公钥私钥加密解密(jsencrypt.js) 1encrypt.setPublicKey(publicKey); 2username = encrypt.encrypt(username); 3password = encrypt.encrypt(password); AES  最常用的对称加密算法，密钥建立时间短、灵敏性好、内存需求低（不管怎样，反正就是好） ","date":"2022-07-25","img":"","permalink":"/posts/computer/pwd/","series":["安全"],"tags":["加解密"],"title":"加密、解密"},{"categories":["对象"],"content":"类型转换  Number(x),x 能转成功的有 1 数字,2 纯数字字符串(会自动去掉前后空格，parseInt 也是),3 空字符串,4true,5false,6null,7[最多只有一个元素且是 1,2 情况]；x 转化过程 1.先调用 valueOf 2.如果返回对象则调用 toString 3.还是对象就报错 1 Number(123|\u0026#39;123\u0026#39;) //123 2 Number(\u0026#39;123abc\u0026#39;) //NaN 3 Number.parseInt(\u0026#39;123abc\u0026#39;) //123 4 Number(true|false) //1|0 5 Number(null|undefined) //0|NaN 6 Number([]) //0 7 Number([1]) //1 8 Number({}) //NaN String(x) x 转化过程,1.调用 toString,2.返回是对象再调用 valueOf,3.还是对象报错 1String(122) //\u0026#34;122\u0026#34; 2String(\u0026#39;123\u0026#39;) //\u0026#34;123\u0026#34; 3String(true|false) //\u0026#34;true\u0026#34;|\u0026#34;false\u0026#34; 4String(undefined|null)//\u0026#34;undefined\u0026#34;|\u0026#34;null\u0026#34; 5String({}) //\u0026#34;[object Object]\u0026#34; 6String([1,2,3]) //\u0026#34;1,2,3\u0026#34; Boolean(x) x 为 undefined、null、-0、+0、NaN、''、为 false，其余全部为 true 1Boolean(new Boolean(false)) //true 自动转换 自动转换场景  不同类型的数据相互运算(123+\u0026lsquo;abc\u0026rsquo;) 对非布尔值类型的数据求布尔值(if(\u0026lsquo;abc\u0026rsquo;){}) 对非数值类型的值使用一元运算符(+ -)  自动转化规则  预期是什么类型的值就调用该类型转换函数 如果该位置预期即可以是字符串也可以是数值，转化为数值 建议显示类型转换 除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。 一元运算符也会把运算子转成数值。+true //1 ","date":"2022-07-25","img":"","permalink":"/posts/objects/type/","series":["类型"],"tags":["类型转换"],"title":"类型转换"},{"categories":["清单"],"content":"es2015(es6) Core features   From var to const/let (var 声明的全局变量，会加入 window 对象，千万不要用 var！) From IIFEs(函数包裹作用域,立即执行函数) to blocks({}) From concatenating strings(拼接字符串 +) to template literals(模版字符串`${}`) From function expressions to arrow functions Multiple return values via(通过) objects 解构赋值 From for to forEach() to for-of 数组遍历优先级 for=\u0026gt;forEach=\u0026gt;for of Handling parameter default values 函数申明默认参数 Handling named parameters   function selectEntries(options) { options = options || {}; // (A) var start = options.start || 0; var end = options.end || -1; var step = options.step || 1; ··· } to function selectEntries({ start=0, end=-1, step=1 } = {}) { ··· }   From arguments to rest parameters From apply() to the spread operator (\u0026hellip;) From concat() to the spread operator (\u0026hellip;) From function expressions in object literals to method definitions   var obj = { foo: function () { ··· }, bar: function () { this.foo(); }, // trailing comma is legal in ES5 } to const obj = { foo() { ··· }, bar() { this.foo(); }, }   From constructors to classes From custom error constructors to subclasses of Error From objects to Maps New string methods New Array methods From CommonJS modules to ES6 modules  语言进化  module and class default is use strict 类和模块隐式为严格模式; ","date":"2022-07-25","img":"","permalink":"/posts/lists/es2015feature/","series":["编码规范"],"tags":["es2015"],"title":"Es2015新特性"},{"categories":["环境"],"content":"隐私、安全 配置的位置 Context（上下文）: http, server, location，（建议配置 server，全局） 隐藏 nginx 版本号  添加server_tokens off; #隐藏掉nginx的版本号  隐藏 response 的 X-Powered-By 字段  添加 fastcgi_hide_header X-Powered-By; #隐藏X-Powered-By  重定向不自动带上端口号  添加 port_in_redirect off; #重定向是否带上端口，关闭后，则响应头Location的URL即是重定向url，不会自动加上端口号  限定可以访问的用户(在明确目标访问用户 ip 情况下配置，不强制要求) 1location / { 2 allow 192.168.1.0/24; #代表允许 192.168.1.* 的任何地址访问 3 allow 10.1.1.0/16; #代表允许 10.1.. 的任何地址访问 4 deny all; 5} 开启日志功能  添加 access_log /log/path/dir; #开启日志功能 添加 access_log off; #关闭日志功能 开启日志后磁盘消耗会增大，需要注意  timeout 配置(可以不配置,都有默认值，下面即默认情况)  添加client_body_timeout 60s; #等待client发送一个请求头的超时时间为60秒 添加client_body_timeout 60s;#请求体（request body）的读超时时间 添加keepalive_timeout 75s; #活动的客户端连接将在服务器端保持打开状态时间 添加send_timeout 60s; #将响应传输到客户端的超时  \u0026mdash;配置总结\u0026mdash; 1server_tokens off;#隐藏掉nginx的版本号 2fastcgi_hide_header X-Powered-By; #隐藏X-Powered-By 3port_in_redirect off; #重定向是否带上端口，关闭后，则响应头Location的URL即是重定向url，不会自动加上端口号 4access_log /log/path/dir; #开启日志功能 安全头 X-Frame-Options X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 frame、iframe、embed、object 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免点击劫持攻击\nX-Frame-Options 有两个可能的值：  X-Frame-Options: DENY X-Frame-Options: SAMEORIGIN  说明  DENY 表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 SAMEORIGIN 表示该页面可以在相同域名页面的 frame 中展示。规范让浏览器厂商决定此选项是否应用于顶层、父级或整个链，有人认为该选项不是很有用，除非所有的祖先页面都属于同一来源  配置建议  Nginx 配置为当前页面可以通过 iframe 嵌入到同源（ip 端口 协议相同）的其它页面中： add_header 'X-Frame-Options' 'SAMEORIGIN';  配置生效位置：  location 下 html 静态页面  X-Content-Type-Options X-Content-Type-Options HTTP 消息头相当于一个提示标志，被服务器用来提示客户端一定要遵循在 Content-Type 首部中对 MIME 类型 的设定，而不能对其进行修改。这就禁用了客户端的 MIME 类型嗅探行为，换句话说，也就是意味着网站管理员确定自己的设置没有问题，要求浏览器只能够用 response 中 content-type 中的类型解析返回的文件，而不要按照浏览器自己的嗅探去解析\nX-Frame-Options 有 1 个可能的值：nosniff 配置建议  add_header 'X-Content-Type-Options' 'nosniff'; add_header 'Content-Type' 'text/html; charset:utf-8';#location /配置了nosniff后需要加上这一行，否则vue路由直接页面显示返回的html字符  下面两种情况的请求将被阻止：  请求类型是\u0026quot;style\u0026quot; 但是 MIME 类型不是 \u0026ldquo;text/css\u0026rdquo;， 请求类型是\u0026quot;script\u0026quot; 但是 MIME 类型不是 JavaScript MIME 类型  配置生效位置： location 下.css .js 文件\nContent-Security-Policy HTTP 响应头Content-Security-Policy 允许站点管理者控制用户代理能够为指定的页面加载哪些资源。除了少数例外情况，设置的政策主要涉及指定服务器的源和脚本结束点。这将帮助防止跨站脚本攻击（Cross-Site Script）\n语法：  Content-Security-Policy: \u0026lt;policy-directive\u0026gt;; \u0026lt;policy-directive\u0026gt; 示例  1//如果网站引入了其他域的资源 可以在\u0026#39;self\u0026#39; 后面加上完整的域（包含协议、端口 2） 3Content-Security-Policy: default-src \u0026#39;self\u0026#39; http://example.com; 4 connect-src \u0026#39;none\u0026#39;; 5Content-Security-Policy: connect-src http://example.com/; 6 script-src http://example.com/; 7 8//如果提示The following directives either allow wildcard sources (or ancestors), are not defined, or are overly broadly defined: 9// frame-ancestors, form-action The directive(s): frame-ancestors, form-action are among the directives that do not fallback to default-src, 10//missing/excluding them is the same as allowing anything. 11//就在后面加指令 frame-ancestors \u0026#39;none\u0026#39; ; form-action \u0026#39;none\u0026#39;; 配置建议 1add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#34;default-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; \u0026#39;unsafe-eval\u0026#39; blob: data:;\u0026#34;; 配置生效位置： location 下 html 文件\nX-XSS-Protection HTTP X-XSS-Protection 响应头是 Internet Explorer，Chrome 和 Safari 的一个特性，当检测到跨站脚本攻击 (XSS (en-US)) 时，浏览器将停止加载页面。若网站设置了良好的 Content-Security-Policy 来禁用内联 JavaScript (\u0026lsquo;unsafe-inline\u0026rsquo;)，现代浏览器不太需要这些保护， 但其仍然可以为尚不支持 CSP(Content-Security-Policy) 的旧版浏览器的用户提供保护\n用法：  X-XSS-Protection: 0 X-XSS-Protection: 1 X-XSS-Protection: 1; mode=block X-XSS-Protection: 1; report=  说明  0 禁止 XSS 过滤。 1 启用 XSS 过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。 1;mode=block 启用 XSS 过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。 1; report= (Chromium only)启用 XSS 过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用 CSP report-uri (en-US)指令的功能发送违规报告。  配置建议 add_header 'X-XSS-Protection' '1;mode=block';  配置生效位置： location 下 html 文件\nStrict-Transport-Security （通常简称为 HSTS）是一个安全功能，它告诉浏览器只能通过 HTTPS 访问当前资源，而不是 HTTP。\n语法：  Strict-Transport-Security: max-age= Strict-Transport-Security: max-age=; includeSubDomains Strict-Transport-Security: max-age=; preload  说明  max-age= 设置在浏览器收到这个请求后的秒的时间内凡是访问这个域名下的请求都使用 HTTPS 请求。 includeSubDomains 可选如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。 preload 可选 查看 预加载 HSTS 获得详情。不是标准的一部分。  配置建议 add_header 'Strict-Transport-Security' 'max-age=31536000; includeSubDomains';  配置生效位置： location 下 html js css 等静态资源文件\n\u0026mdash;安全头配置总结\u0026mdash;  nginx 配置(前后台都在 nginx 中配置)  1# ^~ /back/ 后台接口和 ~* \\.[a-z0-9]+$前端资源都配置一致 2add_header \u0026#39;X-Frame-Options\u0026#39; \u0026#39;SAMEORIGIN\u0026#39;; 3add_header \u0026#39;X-Frame-Options\u0026#39; \u0026#39;DENY\u0026#39;; 4add_header \u0026#39;X-Content-Type-Options\u0026#39; \u0026#39;nosniff\u0026#39;; 5add_header \u0026#39;X-XSS-Protection\u0026#39; \u0026#39;1;mode=block\u0026#39;; 6add_header \u0026#39;Strict-Transport-Security\u0026#39; \u0026#39;max-age=31536000; includeSubdomains\u0026#39;; 7add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#34;default-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; \u0026#39;unsafe-eval\u0026#39; blob: data:;\u0026#34;; ","date":"2022-07-21","img":"","permalink":"/posts/environment/nginx/","series":["静态服务器"],"tags":["nginx"],"title":"Nginx相关配置"},{"categories":["浏览器"],"content":"过程图解 1.缓存过程  如果本地有相关资源的缓存，并且在缓存的时候响应头里面有 etag 或者 last-modified 的情况，这个时候去请求服务器的时候就会是带有条件的 GET 请求(Conditional Validation)。 在请求头里面可能会有两个字段： if-none-match、 if-modified-since，其中 if-none-match 的值是服务器上次返回该资源时响应头里面 etag 的值，if-modified-since 的值是服务器上次返回该资源时响应头里面 last-modified 里的值。 紧接着服务器端就会接收到这个带有条件的 request，然后会根据这两个值去判断缓存的资源是否是最新的。 如果没问题，即资源是最新的情况下就会返回 304，body 为空；不是的话就会返回 200，即目前浏览器端的资源不是最新的，body 里面就是资源体，然后客户端就会用最新返回的资源覆盖掉之前的资源 也就是说。发送这种带条件的请求的必要条件是 资源在浏览器端有缓存，并且在缓存的时候服务器端的 reponse 里面有 etag 或者 last-modified。如果这个条件不满足，发送的请求就是没有条件的(unconditionally)。 此方法弊端：虽然说通过这种方式能够减轻服务器的压力，解决一些请求资源时的性能问题。但是细细看来，还是存在一些浪费：每个都要去带上条件请求服务器来看资源是不是最新的，大多情况下是最新的情况下岂不是每次都在做无意义的验证？  2.缓存改进  Cache-control 用于控制 HTTP 缓存（在 HTTP/1.0 中可能部分没实现，仅仅实现了 Pragma: no-cache）；Expires 表示存在时间，允许客户端在这个时间之前不去检查（发请求），等同 max-age 的效果。但是如果同时存在，则被 Cache-Control 的 max-age 覆盖。（题外话：Expires 要求客户端和服务端的时钟严格同步。HTTP1.1 引入 Cache-Control 来克服 Expires 头的限制。如果 max-age 和 Expires 同时出现，则 max-age 有更高的优先级。） 如果上面 Cache-control、Expires 没有到时间，就不会发送请求，直接用缓存文件，如果到了时间，就走第一点流程 ","date":"2022-07-21","img":"","permalink":"/posts/browser/cache/","series":["缓存策略"],"tags":["etag","last-modified","cache-control","expires"],"title":"浏览器缓存过程"},{"categories":["工具"],"content":"现象：同样的 package.json 及版本， 代码格式化却有两种不同代码质量检查与格式化，导致运行编译不通过 1# 1.匿名函数function 后面有个空格 2[1,2].sort(function (x, y) { 3 return x - y; 4}); 5 6# 2.匿名函数function 后面没有空格 7[1,2].sort(function(x, y) { 8 return x - y; 9}); 原因：eslint-plugin-prettier 依赖的 prettier 版本\u0026gt;=1.13.0,没有限定清楚，prettie1 版本和 2 版本有格式化上的区别，以前老项目安装的是 1.19.1，现在新项目是 2.5.1（在没有 lock 文件锁定版本依赖时） 1\u0026#34;node_modules/eslint-plugin-prettier\u0026#34;: { 2 \u0026#34;version\u0026#34;: \u0026#34;3.4.1\u0026#34;, 3 \u0026#34;resolved\u0026#34;: \u0026#34;https://registry.npmmirror.com/eslint-plugin-prettier/download/eslint-plugin-prettier-3.4.1.tgz\u0026#34;, 4 \u0026#34;integrity\u0026#34;: \u0026#34;sha1-6d2yAO+289Bf/oOxZlpxavSjh+U=\u0026#34;, 5 \u0026#34;dev\u0026#34;: true, 6 \u0026#34;dependencies\u0026#34;: { 7 \u0026#34;prettier-linter-helpers\u0026#34;: \u0026#34;^1.0.0\u0026#34; 8 }, 9 \u0026#34;engines\u0026#34;: { 10 \u0026#34;node\u0026#34;: \u0026#34;\u0026gt;=6.0.0\u0026#34; 11 }, 12 \u0026#34;peerDependencies\u0026#34;: { 13 \u0026#34;eslint\u0026#34;: \u0026#34;\u0026gt;=5.0.0\u0026#34;, 14 \u0026#34;prettier\u0026#34;: \u0026#34;\u0026gt;=1.13.0\u0026#34; 15 }, 16 \u0026#34;peerDependenciesMeta\u0026#34;: { 17 \u0026#34;eslint-config-prettier\u0026#34;: { 18 \u0026#34;optional\u0026#34;: true 19 } 20 } 21} 解决方法：  1.已有工程 package.lock.json 缺失的，需要补齐，自始至终都不要删除，每次需要提交，禁止使用 cnpm 命令，然后执行 npm install prettier@1.19.1 -D,固定为现象 2 的格式化 2.升级 eslint-plugin-prettier 至 4.2.1 使其依赖 prettier 为 2 版本，对应的其它组件也需要升级(不推荐)，后面会配置好后在项目生成工具支持，在新创建工程采用 ","date":"2022-07-21","img":"","permalink":"/posts/tools/prettier/","series":["代码格式化"],"tags":["prettier"],"title":"Prettier格式化函数名后(之间出现空格"},{"categories":["生活"],"content":"年初居家办公，嫌弃笔记本屏幕小，想添加一个扩展屏幕，于是京东、淘宝、咸鱼看了个遍， 各个品牌，各个参数，选择起来真的心累，最终锁定在戴尔和明基这两个品牌， 买了戴尔的 s 系列，2k，27 寸显示器\n买回来后，用了几天，实在无法忍受屏幕做工，屏幕面板与外壳间缝隙不小，而且缝隙有的地方宽， 有的地方窄，最终退货了。\n上班地方有个戴尔的实体店，吃完饭顺便逛了逛，里面摆放的都是 u 系列的显示器，了解到这是戴尔的高端系列，做工当然非常好，之前说的缝隙问题，在设计上就避免了，窄边框，一整块屏幕，完美极了\n看了 u 系列显示器，最便宜的一款都要 1700，不怎么舍得买，于是闲鱼 1100 买了个同款二手的官翻机，1080 分辨率，60hz 刷新率，参数都是最低的\n显示器买了，用了一段时间，又想换了笔记本，原来计划用个两三年再换，但是嫌弃也在一天天增加，还是决定换了它\n看了各种配件价格，为了控制预算，除了核心配件 cpu 主板、机箱， 又在闲鱼买了一些二手的配件\n   产品 价格 规格     12400 b660 1984 新的   内存条 120 8g 2666 旧的   内存条 256 16g 旧的   三星固态硬盘 128g 135 旧的   机械 500g 40 旧的   显卡 0    机箱+3 风扇 258 新的   电源 90 旧的   鼠标键盘 65 新的   8k dp 线 50 新的    total 2998\n一顿折腾，终于组装起来了，发现少了个独立显卡，核显还是太弱了， 看了一遍核显，垃圾显卡都要上千，别人买来用了几年，然后二手卖出来还可以赚不少钱， 价格太畸形了，div 止步于核显，实在不想花几千，买个溢价严重的显卡，什么家庭啊！ 核显就凑合着用吧！\n人的需求是无止境的，不可追求完美，量力而行，快乐无穷。\n","date":"2022-04-28","img":"","permalink":"/posts/days/computer/","series":["计算机div"],"tags":["12400","b660"],"title":"配一台电脑"},{"categories":["对象"],"content":"方法总览   RegExp.prototype.test\n  RegExp.prototype.exec[× 需要 while 遍历,尽量少用,用 match/matchAll 代替 ]\n  String.prototype.match\n  String.prototype.matchAll\n  String.prototype.replace\n  String.prototype.replaceAll\n  String.prototype.split\n  String.prototype.search\n  方法详情 RegExp.prototype.test(String):Boolean, 正则表达式与指定的字符串是否匹配  匹配就返回 true，不匹配就返回 false  1let str = \u0026#39;hello world!\u0026#39;; 2let result = /^hello/.test(str); 3console.log(result); 4// true  如果正则表达式设置了全局标志 连续的执行test()方法，后续的执行将会从 lastIndex 处开始匹配字符串  1var regex = /foo/g; 2 3// regex.lastIndex is at 0 4regex.test(\u0026#39;foo\u0026#39;); // true 5 6// regex.lastIndex is now at 3 7regex.test(\u0026#39;foo\u0026#39;); // false RegExp.prototype.exec(String):[Array|null], 在一个指定字符串中执行一个搜索匹配  如果匹配成功返回一个数组， 并更新正则表达式对象的 lastIndex属性。完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应正则表达式内捕获括号里匹配成功的文本。 如果匹配失败，exec() 方法返回 null，并将 lastIndex 重置为 0 。 如果模式修正符带有 g，需要 while 遍历，多次执行才能得到所有匹配  1var myRe = /ab*/g; 2var str = \u0026#39;abbcdefabh\u0026#39;; 3var myArray; 4while ((myArray = myRe.exec(str)) !== null) { 5 var msg = \u0026#39;Found \u0026#39; + myArray[0] + \u0026#39;. \u0026#39;; 6 msg += \u0026#39;Next match starts at \u0026#39; + myRe.lastIndex; 7 console.log(msg); 8} 9//output 10//Found abb. Next match starts at 3 11//Found ab. Next match starts at 9 12//返回myArray结构如 13[ 14 0: \u0026#34;abb\u0026#34; ---第n次万全匹配 15 1: \u0026#34;a\u0026#34; ---第n次括号匹配 16 groups: undefined 17 index: 0 18 input: \u0026#34;abbcdefabh\u0026#34; 19 length: 1 20] String.prototype.match/matchAll (RegExp):Array, 返回一个字符串匹配正则表达式的结果  如果传入一个非正则表达式对象参数，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 模式修正符 g 的区别    方法 带 g 不带 g     match 1.完整匹配的所有结果，无捕获组 2.第一个完整匹配及其相关的捕获组   matchAll 3.所有完整匹配的结果及分组捕获组的迭代器 ×      1//---1.match带g（×要匹配全部，建议使用matchAll）--- 2var regexp = /t(e)(st(\\d?))/g; 3var str = \u0026#39;test1test2\u0026#39;; 4 5str.match(regexp); 6// Array [\u0026#39;test1\u0026#39;, \u0026#39;test2\u0026#39;] 7 8//---2.match不带g--- 9var regexp = /t(e)(st(\\d?))/g; 10var str = \u0026#39;test1test2\u0026#39;; 11 12str.match(regexp); 13//Array [\u0026#39;test1\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;st1\u0026#39;, \u0026#39;1\u0026#39;, index: 0, input: \u0026#39;test1test2\u0026#39;, groups: undefined] 14 15//---3.matchAll 必须带g(可以替代exec方法)--- 16var regexp = /t(e)(st(\\d?))/g; 17var str = \u0026#39;test1test2\u0026#39;; 18let array = [...str.matchAll(regexp)]; 19 20//返回二维数组 21array[0]; 22// [\u0026#39;test1\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;st1\u0026#39;, \u0026#39;1\u0026#39;, index: 0, input: \u0026#39;test1test2\u0026#39;, length: 4] 23array[1]; 24// [\u0026#39;test2\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;st2\u0026#39;, \u0026#39;2\u0026#39;, index: 5, input: \u0026#39;test1test2\u0026#39;, length: 4] String.prototype.replace/replaceAll (RegExp|substr, newSubStr|function), 替换字符串   该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串\n  第一个参数的区别\n   方法 字符串 正则带 g 正则不带 g     replace 替换第一个匹配到的 替换所有匹配到的(× 建议语义化 replaceAll 替代) 2.替换第一个匹配到的   replaceAll 替换所有匹配的 3.替换所有匹配到的 ×      1//---2 replace 正则不带g--- 2var re = /h/; 3var str = \u0026#34;John Smith\u0026#34;; 4var newstr = str.replace(re, \u0026#34;?\u0026#34;); 5// Jo?n Smith 6console.log(newstr); 7 8//---3 replaceAll--- 9var re = /h/g; 10var str = \u0026#34;John Smith\u0026#34;; 11var newstr = str.replaceAll(re, \u0026#34;?\u0026#34;); 12// Jo?n Smit? 13console.log(newstr);  第 2 个参数为 newSubStr 时,用$1-99表示第 n 个括号匹配的字符串,如果不存在第 n 个分组，那么将会把匹配到到内容替换为字面量。比如不存在第 3 个分组，就会用“$3”替换匹配到的内容;“$\u0026amp;” 插入匹配的子串;“$`”插入当前匹配的子串左边的内容;“$'” 插入当前匹配的子串右边的内容  1//交换一个字符串中两个单词的位置 2var re = /(\\w+)\\s(\\w+)/; 3var str = \u0026#34;John Smith\u0026#34;; 4var newstr = str.replace(re, \u0026#34;$2, $1\u0026#34;); 5// Smith, John 6console.log(newstr);  第 2 个参数为函数时,函数参数为 function(match,p1,p2,\u0026hellip;pn,offset,string),match 匹配到的字符串;p1,p2\u0026hellip;pn 相当于$1-$99 括号匹配;offset 匹配到的子字符串在原字符串中的偏移量;string 被匹配的原字符串  1function replacer(match, p1, p2, p3, offset, string) { 2 // p1 is nondigits, p2 digits, and p3 non-alphanumerics 3 //match= abc12345#$*% 4 return [p1, p2, p3].join(\u0026#39; - \u0026#39;); 5} 6var newString = \u0026#39;abc12345#$*%\u0026#39;.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer); 7console.log(newString); // abc - 12345 - #$*% String.prototype.search (RegExp):index, RegExp 在字符串中首次匹配项的索引  返回首次匹配项的索引，未匹配则返回 -1 类似于正则表达式的test():Boolean方法,'ssass'.indexOf('a')方法; 当要了解更多匹配信息时，可使用 match()方法  1var str = \u0026#34;hey JudE\u0026#34;; 2var re = /[A-Z]/g; 3var re2 = /[.]/g; 4console.log(str.search(re)); // returns 4, which is the index of the first capital letter \u0026#34;J\u0026#34; 5console.log(str.search(re2)); // returns -1 cannot find \u0026#39;.\u0026#39; dot punctuation String.prototype.split ([separator[, limit]] ):Array, 用 separator 把字符串分割成数组  separator 可以是一个字符串或正则表达式  1var myString = \u0026#34;Hello 1 word. Sentence number 2.\u0026#34;; 2var splits = myString.split(/(\\d)/); 3//[ \u0026#34;Hello \u0026#34;, \u0026#34;1\u0026#34;, \u0026#34; word. Sentence number \u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;.\u0026#34; ] 4console.log(splits);  separator如果是数组会转化为字符串  1const myString = \u0026#39;ca,bc,a,bca,bca,bc\u0026#39;; 2 3const splits = myString.split([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;]); 4// myString.split([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;]) is same as myString.split(String([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;])) 5 6console.log(splits); //[\u0026#34;c\u0026#34;, \u0026#34;c,\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;c\u0026#34;]  limit 为一个整数，限定返回的分割片段数量  1var myString = \u0026#34;Hello World. How are you doing?\u0026#34;; 2var splits = myString.split(\u0026#34; \u0026#34;, 3); 3//[\u0026#39;Hello\u0026#39;, \u0026#39;World.\u0026#39;, \u0026#39;How\u0026#39;] 4console.log(splits); ","date":"2021-12-26","img":"","permalink":"/posts/objects/regexp/","series":["正则"],"tags":["replace","exec","test","match","search","split"],"title":"使用正则的场景"},{"categories":["清单"],"content":"1.前端基础知识看下面 3 个网站就够了，不需要东看看西看看。  w3c  MDN  freecodecamp   2.技能点查漏补缺(主要来源于附件图) internet  How does the internet work ? What is HTTP?  Browsers and how they work ? DNS and how it works? What is Domain Name ? What is hosting ?  HTML  Learn the basics Writing Semantic HTML Forms and Validations Conventions and Best Practices SEO Basics Accessibility  css  Learn the basics Making Layouts (Floats, Positioning, Display, Box Model, CSS Grid, Flex Box) Responsive design and Media Queries sass  BEM  Styled Component CSS Modules  icons  iconfont Sketch  PhotoShop   JavaScript  Syntax and Basic Construct Learn DOM Manipulation  Learn FetchAPI /Ajax(XHR)  ES6+ and modular JavaScript  Understand the conceptsHoisting ，EventBubbling，Scope，Prototype ，ShadowDOM，strict  Version Control Systems  Basic Usage of Git  github gitlab  Web Security Knowledge  HTTPS Content Security Policy CORS OWASP Security Risks  Package Managers  npm  cnpm  Build Tools  Task Runners(npm scripts) Module Bundlers(webpack ) Linters and For matters(ESLint ,Prettier )  Pick a Framework  Vue (vuex ,vue-router ,axios ,element-ui ) React (Redux ,Reactstrap ,Material UI,Bootstrap)  Web Components  HTML Templates Custom Elements Shadow DOM   Testing your Apps  Jest   Type Checkers  TypeScript   Progressive Web Apps  Storage Web Sockets  Service Workers  PRPL Pattern RAIL Model Performance Metrics Using Lighthouse  ServerSide Rendering (SSR)  React(Next.js)  Vue(Nuxt.js)   GraphQL  Apollo   Static Site Generators  Next.js GatsbyJS Hugo  Jekyll Nuxt.js  Mobile Applications  React Native   Desktop Applictions  Electron   Web Assembly(WASM)  Go   开发工具  vscode  Fiddler 或 Charles Postman Chrome DevTools   自制工具  创建项目 cli 工具  可视化  SVG  D3  Raphaël  Snap    Canvas 2D  Echarts  HighCharts    WebGL  Three     微前端  qiankun  single-spa   设计模式  单例模式  工厂模式  观察者模式  发布订阅模式  代理模式  适配器模式  策略模式  命令模式   数据结构  堆（Heap） 栈（Stack） 队列（Queue） 链表（Linked List） 数组（Array） 树（Tree） 集合（Set） 哈希表（Map）  算法  排序  冒泡排序 选择排序 插入排序 快速排序 希尔排序 归并排序 堆排序 计数排序 基数排序   检索  线性搜索 二分查找 索引 深度优先搜索（DFS） 广度优先搜索（BFS）   Diff  JavaScript 算法与数据结构   计算机网络  OSI 七层模型   后端扩展  nodejs   3.经常上github 查看前端开源库源码，是快速提高技能的重要方式  \u0026mdash;附件图片\u0026mdash;\n","date":"2021-12-20","img":"","permalink":"/posts/lists/guide/","series":["前端规划"],"tags":["技能点"],"title":"前端学习路线图"},{"categories":["生活"],"content":"2021 年 12 月 19 日在两步路 App，报名参加了阳台山大环户外，全程有 42.43 公里，最高海拔 569 米，累计爬升 3099 米，天生牛犊不怕虎，初生新驴不怕虐，带着减肥的目标报名了\n有个热心队友，自掏腰包 1800，设立了爬山的奖金，男女各组 1-3 名奖励 200，男子 4-10 名奖励 100(女生少，只设 3 个奖)，这个热心队友是真的热心，一大早就煮了很多鸡腿带过来给大家吃，出钱又出东西，真的没话说。\n6 点半起床，楼下吃完热干面就急匆匆的打车前往阳台山胜利大营救，一到就傻眼了，全都是瘦瘦的肌肉猛男猛女，装备一看就是专业的队伍，听说很多都是户外运动比赛的冠军，7 点 35 爬山开始。\n这个爬山路径很变态，八上八下，好不容易爬到山顶又下来，然后又爬到山顶，走完了 8 条上山下山路径，上山路都是选择的最陡的，对身体素质考验很大\n一开始跟着队伍跑了一两公里，体力就有点不支了(平常运动太少了)，右腿也有点抽筋了，一瘸一拐的坚持到了应人石，到应人石已经 1 点多了，腿实在受不了，就下撤了，爬了 18 公里多。\n完赛的大神成绩汇总单\n女大神上坡都是跑的，好厉害\nYour browser does not support the video tag.  通过这次户外，认识到了运动需要一步步提升，强来容易带来身体上的伤害，需要先找难度低一点的，等体能提升了再慢慢挑战难一点的运动。\n","date":"2021-12-19","img":"","permalink":"/posts/days/sport20211219/","series":["户外"],"tags":["阳台山"],"title":"羊台山大环徒步"},{"categories":["计算机基础"],"content":"When you have some binary data that you want to ship across a network, you generally don\u0026rsquo;t do it by just streaming the bits and bytes over the wire in a raw format. Why? because some media are made for streaming text. You never know \u0026ndash; some protocols may interpret your binary data as control characters (like a modem), or your binary data could be screwed up because the underlying protocol might think that you\u0026rsquo;ve entered a special character combination (like how FTP translates line endings). So to get around this, people encode the binary data into characters. Base64 is one of these types of encodings. Why 64? Because you can generally rely on the same 64 characters being present in many character sets, and you can be reasonably confident that your data\u0026rsquo;s going to end up on the other side of the wire uncorrupted\n标准 ASCII 码，使用 7 位二进制数 2（2^7=128,剩下的 1 位二进制为 0）来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符，码表如下\nbase64 使用大写和小写字母，数字 0 到 9，+ /共 64 个字符编码，码表如下\n那么怎么将 ascii 字符\u0026rsquo;ab',转化为 base64 码，规则是怎么样的呢？\n我们在 ascii 码表分别找到 a，b 的码值为 97,98，用 2 进制表示为 1100001，1100010(可以使用方法 97..toString(2)得到)，不足 8 位的在前面补 0，那么‘ab’二进制表示就是 01100001 01100010\nbase64 只有 64 个字符，只需要 6（2^6=64）位就可以容纳，那么我们可以分割成 011000 010110 0010，① 后面不足 6 位在后面补 0，于是就成为了 011000 010110 001000，我们得出他们的 10 进制分别为 24,22,8（可以使用 parseInt(11000,2)计算出）\n通过比对 base64 码，我们分别找到 24,22,8 对应的字符为 Y,W,I\n根据规定转化后的长度需要是 4 的倍数，② 不足部分在后面加‘=’，于是变成了 YWI=,我们通过 btoa(\u0026lsquo;ab\u0026rsquo;)方法验证，结果正确\nab 字符实际有效占用的空间是 27=14 位（标准的 ascii 只有 7 位有效的)，转化为 base64 后，48=32 位（这里加了个=，多了 8 位），因此 base64 编码后会增加传输量，具体增加多少取决于 ① ② 处\n","date":"2021-12-16","img":"","permalink":"/posts/computer/ascii2base64/","series":["编码"],"tags":["base64","ascii"],"title":"Ascii转base64"},{"categories":["环境"],"content":"前言 同事问我，你有什么梦想，我想了半天没有回答出来，思来想去，对于梦想，大多数都跟钱有关，话说没有钱解决不了的问题，解决不了那就是钱不够，那么我们有没有什么东西是很重要，又是钱买不到的，或者不容易买到的呢\n健康的身体，话说身体是革命的本钱，是所有的基础，花时间去锻炼身体，健康营养的饮食，良好愉悦的心情，是保持健康的最低条件\n一技之长，人生的价值在于被利用价值，人不可能做好很多事，于是根据自己能力选择合适的事就很重要，做一行爱一行，拥有难以替代的特长，是生存的保障\n对于未来的希望，未来很漫长，需要有期待，有诗，有远方\n能够陪伴你的好友，人是群体动物，社会关系构筑了现代文明体系，每个人都很忙，在快节奏的城市，能够有交集那也是难得的缘分\n2022 决定好好写博客，促使自己学习，变的更好(这也是建站目的)\n域名申请 域名我使用的阿里云的万网 购买的 10 年期限，199 人民币，也可以不买域名，买域名只是让网站地址更加好记忆，看起来高大上一点，免费静态托管网站提供的地址太长不友好\n域名买下来后需要在购买商那里完成实名信息登记\nicp 备案与免费静态服务器 根据国家规定，国内的网站都需要备案，备案就是企业或个人提交建站相关信息到对应服务商，用于国家监管，服务器在国外就不需要备案\n找到的免费的静态托管网站有 gitee 和 github，gitee 在国内需要备案，不提供个性化域名服务(收费版本可以)，但是访问速度会快于 github，为了使用个性化域名，所以我选择了 github\nhugo 工程创建与编译  下载 hugo 软件 生成网站 将解压的可执行文件路径 bin 目录加入环境变量 path 新开 cmd 命令窗口，创建工程  1hugo new site myblog 2cd myblog 3新建目录themes 将hugo-theme-bootstrap 下载下来放在 themes 目录下 在 myblog 工程根目录下执行下列命令  1cp -a themes/hugo-theme-bootstrap/exampleSite/* . 2//如果你使用的是 Windows，请改用 xcopy .\\themes\\hugo-theme-bootstrap\\exampleSite /E 运行工程 hugo server --watch 编译文件到 docs 目录下 hugo -d docs 将整个工程提交到 github 仓库中  域名解析与 github page 设置  在域名服务商将域名 CNAME 到 github 服务器，格式为 github 用户名.github.io（@记录为不带 www 的域名解析）  点开刚刚提交到的 github 仓库，进入 settings 目录 找到 GitHub Pages,点击 Check it out here 填写代码所在分支，选择/docs 目录，点保存，Custom domain 填写自己刚刚解析的域名地址，点保存   我们可以用 github Actions 自动构建，来优化流程，这样每次 commit，就会自动编译，部署  配置 settings pages 项,部署分支改为 gh-pages,目录选择/root,工作流编译的代码会放在这里 配置 Actions 项，点击最上面的set up a workflow yourself， 将下面的工作流代码复制进.github/workflows/你的分支名.yml，然后 start commit  1# This is a basic workflow to help you get started with Actions 2name: CI 3# Controls when the workflow will run 4 5on: 6# Triggers the workflow on push or pull request events but only for the main branch 7push: 8branches: [main] 9pull_request: 10branches: [main] 11# Allows you to run this workflow manually from the Actions tab 12workflow_dispatch: 13# A workflow run is made up of one or more jobs that can run sequentially or in parallel 14jobs: 15# This workflow contains a single job called \u0026#34;build\u0026#34; 16build: # The type of runner that the job will run on 17runs-on: ubuntu-latest 18 # Steps represent a sequence of tasks that will be executed as part of the job 19 steps: 20 # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it 21 - uses: actions/checkout@v2 22 23 # Runs a single command using the runners shell 24 - name: Run a one-line script 25 run: echo Hello, world! 26 27 - name: Setup Hugo 28 uses: peaceiris/actions-hugo@v2 29 with: 30 hugo-version: \u0026#34;0.90.1\u0026#34; 31 # extended: true 32 33 - name: Build 34 run: hugo -d docs 35 36 # 将main分支打包后的docs文件夹内容放到gh-pages分支上 37 - name: Deploy 38 uses: peaceiris/actions-gh-pages@v3 39 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} 40 with: 41 github_token: ${{ secrets.GITHUB_TOKEN }} 42 publish_dir: ./docs 提交代码后，再次进入 Actions,你就可以看到 workflows 运行情况，点击具体的任务，可以重新跑这个任务，查看 workflow 具体的执行步骤 ","date":"2021-12-15","img":"","permalink":"/posts/environment/buildwebsite/","series":["博客"],"tags":["hugo","hugo-theme-bootstrap","github page"],"title":"使用hugo搭建博客"},{"categories":["工具"],"content":"git 命令 代码拉取  git 配置用户名邮箱 $ git config --global user.name \u0026quot;John Doe\u0026quot; $ git config --global user.email johndoe@example.com 克隆仓库 $ git clone git://github.com/schacon/ticgit.git git clone 只能 clone 远程库的 master 分支，无法 clone 所有分支  branch 操作  创建分支 git branch 分支名; 切换分支 git checkout 分支名， 创建分支并切换到对应分支git checkout -b 分支名 [origin/branchName] 删除本地某分支 git branch -d 分支名 查看本地分支情况 git branch 查看远程分支 git branch -r 分支重命名 git branch -m oldname newname 将 test 分支合并进当前分支 git merge test  tag 操作  查看 git tag 给当前 commit 添加 tag git tag -a tagname -m \u0026quot;comment\u0026quot; or git tag tagname 删除 tag git tag -d tagname 提交 tag git push origin tagname or once push all git push origin --tags  代码状态  显示有变更的文件 git status  显示当前分支的版本历史 git log [--pretty=oneline] 显示历史操作记录 git reflog 查看修改情况 git diff   代码还原  语法 git reset －－[mixed 默认|hard|soft] commit 号|HEAD~n|HEAD^^^|HEAD^ hard－\u0026gt;add 之前文件也还原(回到 1) mixed－\u0026gt;add 之前(回到 2) soft－\u0026gt;commit 之前，保留 add(回到 3) \u0026lt;\u0026ndash;1-modify\u0026ndash;2\u0026ndash;add\u0026ndash;3\u0026ndash;commit\u0026ndash;4\u0026ndash;\u0026gt; 优先级为:从暂存区,当前最后一次 commit,拿此文件替换工作区此文件 git checkout --文件名  提交代码  git add [file|.|-A]  git commit -a --amend (修改上一次 commit 信息) git commit -m “注释” (添加本次 commit 的注释) 更新远程代码  git pull origin branchname 提交代码 git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; or samename git push origin branchname (在解决完冲突后，重新 add commit push）  gitlab 配置  打开 git bash 窗口 查看是否已经存在 SSH key pair cat ~/.ssh/id_rsa.pub 存在就跳过生成步骤 4 生成 ssh key 命令： ssh-keygen -t rsa -C \u0026ldquo;your email address\u0026rdquo; ssh 公钥 id_rsa.pub 拷贝到 gitlab\u0026rsquo;右上角\u0026gt;头像\u0026gt;设置\u0026gt;ssh 密钥' 官方相关说明   github 配置  github 配置类似 gitlab 配置 ssh 公钥 id_rsa.pub 可以共用，不需要重新生成(哪怕 your email address 不一样也可以) 通信凭证在 2021.8 月禁用了 account passwords 方式 默认方式由 ssh 变为了 https token ，代码仓库地址默认是 https 而不再是 ssh  按照原来 ssh 配置后，执行ssh -T git@github.com 提示 You\u0026rsquo;ve successfully authenticated 则凭证正确 复制 ssh 地址， git clone 代码(注意要选择 ssh 地址，因为配置的凭证是 ssh 的),或者用 https 地址，配置新的 https token 认证方式  tapd 与 gitlab 关联  tapd 文档相关说明  ","date":"2021-12-15","img":"","permalink":"/posts/tools/git/","series":["版本管理工具"],"tags":["git","gitlab","tapd","github"],"title":"Git相关使用"},{"categories":null,"content":" 主要用于书写前端技术博客和记录生活点滴 本博客代码托管于 github page 使用了 hugo-theme-bootstrap 博客主题 爱前端(iqianduan)首次部署于 2021-12-14  ","date":"2019-02-28","img":"","permalink":"/about/","series":null,"tags":null,"title":"关于"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/faq/","series":null,"tags":null,"title":"Frequently Asked Questions"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/offline/","series":null,"tags":null,"title":"Offline"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/contact/","series":null,"tags":null,"title":"联系我们"}]