[{"categories":["前端"],"content":"隐私、安全 配置的位置 Context（上下文）: http, server, location，（建议配置 server，全局） 隐藏 nginx 版本号  添加server_tokens off; #隐藏掉nginx的版本号  隐藏 response 的 X-Powered-By 字段  添加 fastcgi_hide_header X-Powered-By; #隐藏X-Powered-By  重定向不自动带上端口号  添加 port_in_redirect off; #重定向是否带上端口，关闭后，则响应头Location的URL即是重定向url，不会自动加上端口号  限定可以访问的用户(在明确目标访问用户 ip 情况下配置，不强制要求) 1location / { 2 allow 192.168.1.0/24; #代表允许 192.168.1.* 的任何地址访问 3 allow 10.1.1.0/16; #代表允许 10.1.. 的任何地址访问 4 deny all; 5} 开启日志功能  添加 access_log /log/path/dir; #开启日志功能 添加 access_log off; #关闭日志功能 开启日志后磁盘消耗会增大，需要注意  timeout 配置(可以不配置,都有默认值，下面即默认情况)  添加client_body_timeout 60s; #等待client发送一个请求头的超时时间为60秒 添加client_body_timeout 60s;#请求体（request body）的读超时时间 添加keepalive_timeout 75s; #活动的客户端连接将在服务器端保持打开状态时间 添加send_timeout 60s; #将响应传输到客户端的超时  \u0026mdash;配置总结\u0026mdash; 1server_tokens off;#隐藏掉nginx的版本号 2fastcgi_hide_header X-Powered-By; #隐藏X-Powered-By 3port_in_redirect off; #重定向是否带上端口，关闭后，则响应头Location的URL即是重定向url，不会自动加上端口号 4access_log /log/path/dir; #开启日志功能 安全头 X-Frame-Options X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 frame、iframe、embed、object 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免点击劫持攻击\nX-Frame-Options 有两个可能的值：  X-Frame-Options: DENY X-Frame-Options: SAMEORIGIN  说明  DENY 表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 SAMEORIGIN 表示该页面可以在相同域名页面的 frame 中展示。规范让浏览器厂商决定此选项是否应用于顶层、父级或整个链，有人认为该选项不是很有用，除非所有的祖先页面都属于同一来源  配置建议  Nginx 配置为当前页面可以通过 iframe 嵌入到同源（ip 端口 协议相同）的其它页面中： add_header 'X-Frame-Options' 'SAMEORIGIN';  配置生效位置：  location 下 html 静态页面  X-Content-Type-Options X-Content-Type-Options HTTP 消息头相当于一个提示标志，被服务器用来提示客户端一定要遵循在 Content-Type 首部中对 MIME 类型 的设定，而不能对其进行修改。这就禁用了客户端的 MIME 类型嗅探行为，换句话说，也就是意味着网站管理员确定自己的设置没有问题，要求浏览器只能够用 response 中 content-type 中的类型解析返回的文件，而不要按照浏览器自己的嗅探去解析\nX-Frame-Options 有 1 个可能的值：nosniff 配置建议  add_header 'X-Content-Type-Options' 'nosniff'; add_header 'Content-Type' 'text/html; charset:utf-8';#location /配置了nosniff后需要加上这一行，否则vue路由直接页面显示返回的html字符  下面两种情况的请求将被阻止：  请求类型是\u0026quot;style\u0026quot; 但是 MIME 类型不是 \u0026ldquo;text/css\u0026rdquo;， 请求类型是\u0026quot;script\u0026quot; 但是 MIME 类型不是 JavaScript MIME 类型  配置生效位置： location 下.css .js 文件\nContent-Security-Policy HTTP 响应头Content-Security-Policy 允许站点管理者控制用户代理能够为指定的页面加载哪些资源。除了少数例外情况，设置的政策主要涉及指定服务器的源和脚本结束点。这将帮助防止跨站脚本攻击（Cross-Site Script）\n语法：  Content-Security-Policy: \u0026lt;policy-directive\u0026gt;; \u0026lt;policy-directive\u0026gt; 示例  1//如果网站引入了其他域的资源 可以在\u0026#39;self\u0026#39; 后面加上完整的域（包含协议、端口 2） 3Content-Security-Policy: default-src \u0026#39;self\u0026#39; http://example.com; 4 connect-src \u0026#39;none\u0026#39;; 5Content-Security-Policy: connect-src http://example.com/; 6 script-src http://example.com/; 7 8//如果提示The following directives either allow wildcard sources (or ancestors), are not defined, or are overly broadly defined: 9// frame-ancestors, form-action The directive(s): frame-ancestors, form-action are among the directives that do not fallback to default-src, 10//missing/excluding them is the same as allowing anything. 11//就在后面加指令 frame-ancestors \u0026#39;none\u0026#39; ; form-action \u0026#39;none\u0026#39;; 配置建议 1add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#34;default-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; \u0026#39;unsafe-eval\u0026#39; blob: data:;\u0026#34;; 配置生效位置： location 下 html 文件\nX-XSS-Protection HTTP X-XSS-Protection 响应头是 Internet Explorer，Chrome 和 Safari 的一个特性，当检测到跨站脚本攻击 (XSS (en-US)) 时，浏览器将停止加载页面。若网站设置了良好的 Content-Security-Policy 来禁用内联 JavaScript (\u0026lsquo;unsafe-inline\u0026rsquo;)，现代浏览器不太需要这些保护， 但其仍然可以为尚不支持 CSP(Content-Security-Policy) 的旧版浏览器的用户提供保护\n用法：  X-XSS-Protection: 0 X-XSS-Protection: 1 X-XSS-Protection: 1; mode=block X-XSS-Protection: 1; report=  说明  0 禁止 XSS 过滤。 1 启用 XSS 过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。 1;mode=block 启用 XSS 过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。 1; report= (Chromium only)启用 XSS 过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用 CSP report-uri (en-US)指令的功能发送违规报告。  配置建议 add_header 'X-XSS-Protection' '1;mode=block';  配置生效位置： location 下 html 文件\nStrict-Transport-Security （通常简称为 HSTS）是一个安全功能，它告诉浏览器只能通过 HTTPS 访问当前资源，而不是 HTTP。\n语法：  Strict-Transport-Security: max-age= Strict-Transport-Security: max-age=; includeSubDomains Strict-Transport-Security: max-age=; preload  说明  max-age= 设置在浏览器收到这个请求后的秒的时间内凡是访问这个域名下的请求都使用 HTTPS 请求。 includeSubDomains 可选如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。 preload 可选 查看 预加载 HSTS 获得详情。不是标准的一部分。  配置建议 add_header 'Strict-Transport-Security' 'max-age=31536000; includeSubDomains';  配置生效位置： location 下 html js css 等静态资源文件\n\u0026mdash;安全头配置总结\u0026mdash;  nginx 配置(前后台都在 nginx 中配置)  1# ^~ /back/ 后台接口和 ~* \\.[a-z0-9]+$前端资源都配置一致 2add_header \u0026#39;X-Frame-Options\u0026#39; \u0026#39;SAMEORIGIN\u0026#39;; 3add_header \u0026#39;X-Frame-Options\u0026#39; \u0026#39;DENY\u0026#39;; 4add_header \u0026#39;X-Content-Type-Options\u0026#39; \u0026#39;nosniff\u0026#39;; 5add_header \u0026#39;X-XSS-Protection\u0026#39; \u0026#39;1;mode=block\u0026#39;; 6add_header \u0026#39;Strict-Transport-Security\u0026#39; \u0026#39;max-age=31536000; includeSubdomains\u0026#39;; 7add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#34;default-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; \u0026#39;unsafe-eval\u0026#39; blob: data:;\u0026#34;; ","date":"2022-07-21","img":"","permalink":"/posts/nginx/","series":["部署"],"tags":["nginx"],"title":"Nginx相关配置"},{"categories":["前端"],"content":"过程图解 1.缓存过程  如果本地有相关资源的缓存，并且在缓存的时候响应头里面有 etag 或者 last-modified 的情况，这个时候去请求服务器的时候就会是带有条件的 GET 请求(Conditional Validation)。 在请求头里面可能会有两个字段： if-none-match、 if-modified-since，其中 if-none-match 的值是服务器上次返回该资源时响应头里面 etag 的值，if-modified-since 的值是服务器上次返回该资源时响应头里面 last-modified 里的值。 紧接着服务器端就会接收到这个带有条件的 request，然后会根据这两个值去判断缓存的资源是否是最新的。 如果没问题，即资源是最新的情况下就会返回 304，body 为空；不是的话就会返回 200，即目前浏览器端的资源不是最新的，body 里面就是资源体，然后客户端就会用最新返回的资源覆盖掉之前的资源 也就是说。发送这种带条件的请求的必要条件是 资源在浏览器端有缓存，并且在缓存的时候服务器端的 reponse 里面有 etag 或者 last-modified。如果这个条件不满足，发送的请求就是没有条件的(unconditionally)。 此方法弊端：虽然说通过这种方式能够减轻服务器的压力，解决一些请求资源时的性能问题。但是细细看来，还是存在一些浪费：每个都要去带上条件请求服务器来看资源是不是最新的，大多情况下是最新的情况下岂不是每次都在做无意义的验证？  2.缓存改进  Cache-control 用于控制 HTTP 缓存（在 HTTP/1.0 中可能部分没实现，仅仅实现了 Pragma: no-cache）；Expires 表示存在时间，允许客户端在这个时间之前不去检查（发请求），等同 max-age 的效果。但是如果同时存在，则被 Cache-Control 的 max-age 覆盖。（题外话：Expires 要求客户端和服务端的时钟严格同步。HTTP1.1 引入 Cache-Control 来克服 Expires 头的限制。如果 max-age 和 Expires 同时出现，则 max-age 有更高的优先级。） 如果上面 Cache-control、Expires 没有到时间，就不会发送请求，直接用缓存文件，如果到了时间，就走第一点流程 ","date":"2022-07-21","img":"","permalink":"/posts/cache/","series":["部署"],"tags":["cache"],"title":"浏览器缓存过程"},{"categories":["前端"],"content":"现象：同样的 package.json 及版本， 代码格式化却有两种不同代码质量检查与格式化，导致运行编译不通过 1# 1.匿名函数function 后面有个空格 2[1,2].sort(function (x, y) { 3 return x - y; 4}); 5 6# 2.匿名函数function 后面没有空格 7[1,2].sort(function(x, y) { 8 return x - y; 9}); 原因：eslint-plugin-prettier 依赖的 prettier 版本\u0026gt;=1.13.0,没有限定清楚，prettie1 版本和 2 版本有格式化上的区别，以前老项目安装的是 1.19.1，现在新项目是 2.5.1（在没有 lock 文件锁定版本依赖时） 1\u0026#34;node_modules/eslint-plugin-prettier\u0026#34;: { 2 \u0026#34;version\u0026#34;: \u0026#34;3.4.1\u0026#34;, 3 \u0026#34;resolved\u0026#34;: \u0026#34;https://registry.npmmirror.com/eslint-plugin-prettier/download/eslint-plugin-prettier-3.4.1.tgz\u0026#34;, 4 \u0026#34;integrity\u0026#34;: \u0026#34;sha1-6d2yAO+289Bf/oOxZlpxavSjh+U=\u0026#34;, 5 \u0026#34;dev\u0026#34;: true, 6 \u0026#34;dependencies\u0026#34;: { 7 \u0026#34;prettier-linter-helpers\u0026#34;: \u0026#34;^1.0.0\u0026#34; 8 }, 9 \u0026#34;engines\u0026#34;: { 10 \u0026#34;node\u0026#34;: \u0026#34;\u0026gt;=6.0.0\u0026#34; 11 }, 12 \u0026#34;peerDependencies\u0026#34;: { 13 \u0026#34;eslint\u0026#34;: \u0026#34;\u0026gt;=5.0.0\u0026#34;, 14 \u0026#34;prettier\u0026#34;: \u0026#34;\u0026gt;=1.13.0\u0026#34; 15 }, 16 \u0026#34;peerDependenciesMeta\u0026#34;: { 17 \u0026#34;eslint-config-prettier\u0026#34;: { 18 \u0026#34;optional\u0026#34;: true 19 } 20 } 21} 解决方法：  1.已有工程 package.lock.json 缺失的，需要补齐，自始至终都不要删除，每次需要提交，禁止使用 cnpm 命令，然后执行 npm install prettier@1.19.1 -D,固定为现象 2 的格式化 2.升级 eslint-plugin-prettier 至 4.2.1 使其依赖 prettier 为 2 版本，对应的其它组件也需要升级(不推荐)，后面会配置好后在项目生成工具支持，在新创建工程采用 ","date":"2022-07-21","img":"","permalink":"/posts/prettier/","series":["代码格式化"],"tags":["prettier"],"title":"Prettier格式化函数名后(之间出现空格"},{"categories":["台式机"],"content":"年初居家办公，嫌弃笔记本屏幕小，想添加一个扩展屏幕，于是京东、淘宝、咸鱼看了个遍， 各个品牌，各个参数，选择起来真的心累，最终锁定在戴尔和明基这两个品牌， 买了戴尔的 s 系列，2k，27 寸显示器\n买回来后，用了几天，实在无法忍受屏幕做工，屏幕面板与外壳间缝隙不小，而且缝隙有的地方宽， 有的地方窄，最终退货了。\n上班地方有个戴尔的实体店，吃完饭顺便逛了逛，里面摆放的都是 u 系列的显示器，了解到这是戴尔的高端系列，做工当然非常好，之前说的缝隙问题，在设计上就避免了，窄边框，一整块屏幕，完美极了\n看了 u 系列显示器，最便宜的一款都要 1700，不怎么舍得买，于是闲鱼 1100 买了个同款二手的官翻机，1080 分辨率，60hz 刷新率，参数都是最低的\n显示器买了，用了一段时间，又想换了笔记本，原来计划用个两三年再换，但是嫌弃也在一天天增加，还是决定换了它\n看了各种配件价格，为了控制预算，除了核心配件 cpu 主板、机箱， 又在闲鱼买了一些二手的配件\n   产品 价格 规格     12400 b660 1984 新的   内存条 120 8g 2666 旧的   内存条 256 16g 旧的   三星固态硬盘 128g 135 旧的   机械 500g 40 旧的   显卡 0    机箱+3 风扇 258 新的   电源 90 旧的   鼠标键盘 65 新的   8k dp 线 50 新的    total 2998\n一顿折腾，终于组装起来了，发现少了个独立显卡，核显还是太弱了， 看了一遍核显，垃圾显卡都要上千，别人买来用了几年，然后二手卖出来还可以赚不少钱， 价格太畸形了，div 止步于核显，实在不想花几千，买个溢价严重的显卡，什么家庭啊！ 核显就凑合着用吧！\n人的需求是无止境的，不可追求完美，量力而行，快乐无穷。\n","date":"2022-04-28","img":"","permalink":"/posts/computer/","series":["电子产品"],"tags":["组装电脑"],"title":"配一台电脑"},{"categories":["正则"],"content":"方法总览   RegExp.prototype.test\n  RegExp.prototype.exec[× 需要 while 遍历,尽量少用,用 match/matchAll 代替 ]\n  String.prototype.match\n  String.prototype.matchAll\n  String.prototype.replace\n  String.prototype.replaceAll\n  String.prototype.split\n  String.prototype.search\n  方法详情 RegExp.prototype.test(String):Boolean, 正则表达式与指定的字符串是否匹配  匹配就返回 true，不匹配就返回 false  1let str = \u0026#39;hello world!\u0026#39;; 2let result = /^hello/.test(str); 3console.log(result); 4// true  如果正则表达式设置了全局标志 连续的执行test()方法，后续的执行将会从 lastIndex 处开始匹配字符串  1var regex = /foo/g; 2 3// regex.lastIndex is at 0 4regex.test(\u0026#39;foo\u0026#39;); // true 5 6// regex.lastIndex is now at 3 7regex.test(\u0026#39;foo\u0026#39;); // false RegExp.prototype.exec(String):[Array|null], 在一个指定字符串中执行一个搜索匹配  如果匹配成功返回一个数组， 并更新正则表达式对象的 lastIndex属性。完全匹配成功的文本将作为返回数组的第一项，从第二项起，后续每项都对应正则表达式内捕获括号里匹配成功的文本。 如果匹配失败，exec() 方法返回 null，并将 lastIndex 重置为 0 。 如果模式修正符带有 g，需要 while 遍历，多次执行才能得到所有匹配  1var myRe = /ab*/g; 2var str = \u0026#39;abbcdefabh\u0026#39;; 3var myArray; 4while ((myArray = myRe.exec(str)) !== null) { 5 var msg = \u0026#39;Found \u0026#39; + myArray[0] + \u0026#39;. \u0026#39;; 6 msg += \u0026#39;Next match starts at \u0026#39; + myRe.lastIndex; 7 console.log(msg); 8} 9//output 10//Found abb. Next match starts at 3 11//Found ab. Next match starts at 9 12//返回myArray结构如 13[ 14 0: \u0026#34;abb\u0026#34; ---第n次万全匹配 15 1: \u0026#34;a\u0026#34; ---第n次括号匹配 16 groups: undefined 17 index: 0 18 input: \u0026#34;abbcdefabh\u0026#34; 19 length: 1 20] String.prototype.match/matchAll (RegExp):Array, 返回一个字符串匹配正则表达式的结果  如果传入一个非正则表达式对象参数，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 模式修正符 g 的区别    方法 带 g 不带 g     match 1.完整匹配的所有结果，无捕获组 2.第一个完整匹配及其相关的捕获组   matchAll 3.所有完整匹配的结果及分组捕获组的迭代器 ×      1//---1.match带g（×要匹配全部，建议使用matchAll）--- 2var regexp = /t(e)(st(\\d?))/g; 3var str = \u0026#39;test1test2\u0026#39;; 4 5str.match(regexp); 6// Array [\u0026#39;test1\u0026#39;, \u0026#39;test2\u0026#39;] 7 8//---2.match不带g--- 9var regexp = /t(e)(st(\\d?))/g; 10var str = \u0026#39;test1test2\u0026#39;; 11 12str.match(regexp); 13//Array [\u0026#39;test1\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;st1\u0026#39;, \u0026#39;1\u0026#39;, index: 0, input: \u0026#39;test1test2\u0026#39;, groups: undefined] 14 15//---3.matchAll 必须带g(可以替代exec方法)--- 16var regexp = /t(e)(st(\\d?))/g; 17var str = \u0026#39;test1test2\u0026#39;; 18let array = [...str.matchAll(regexp)]; 19 20//返回二维数组 21array[0]; 22// [\u0026#39;test1\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;st1\u0026#39;, \u0026#39;1\u0026#39;, index: 0, input: \u0026#39;test1test2\u0026#39;, length: 4] 23array[1]; 24// [\u0026#39;test2\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;st2\u0026#39;, \u0026#39;2\u0026#39;, index: 5, input: \u0026#39;test1test2\u0026#39;, length: 4] String.prototype.replace/replaceAll (RegExp|substr, newSubStr|function), 替换字符串   该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串\n  第一个参数的区别\n   方法 字符串 正则带 g 正则不带 g     replace 替换第一个匹配到的 替换所有匹配到的(× 建议语义化 replaceAll 替代) 2.替换第一个匹配到的   replaceAll 替换所有匹配的 3.替换所有匹配到的 ×      1//---2 replace 正则不带g--- 2var re = /h/; 3var str = \u0026#34;John Smith\u0026#34;; 4var newstr = str.replace(re, \u0026#34;?\u0026#34;); 5// Jo?n Smith 6console.log(newstr); 7 8//---3 replaceAll--- 9var re = /h/g; 10var str = \u0026#34;John Smith\u0026#34;; 11var newstr = str.replaceAll(re, \u0026#34;?\u0026#34;); 12// Jo?n Smit? 13console.log(newstr);  第 2 个参数为 newSubStr 时,用$1-99表示第 n 个括号匹配的字符串,如果不存在第 n 个分组，那么将会把匹配到到内容替换为字面量。比如不存在第 3 个分组，就会用“$3”替换匹配到的内容;“$\u0026amp;” 插入匹配的子串;“$`”插入当前匹配的子串左边的内容;“$'” 插入当前匹配的子串右边的内容  1//交换一个字符串中两个单词的位置 2var re = /(\\w+)\\s(\\w+)/; 3var str = \u0026#34;John Smith\u0026#34;; 4var newstr = str.replace(re, \u0026#34;$2, $1\u0026#34;); 5// Smith, John 6console.log(newstr);  第 2 个参数为函数时,函数参数为 function(match,p1,p2,\u0026hellip;pn,offset,string),match 匹配到的字符串;p1,p2\u0026hellip;pn 相当于$1-$99 括号匹配;offset 匹配到的子字符串在原字符串中的偏移量;string 被匹配的原字符串  1function replacer(match, p1, p2, p3, offset, string) { 2 // p1 is nondigits, p2 digits, and p3 non-alphanumerics 3 //match= abc12345#$*% 4 return [p1, p2, p3].join(\u0026#39; - \u0026#39;); 5} 6var newString = \u0026#39;abc12345#$*%\u0026#39;.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer); 7console.log(newString); // abc - 12345 - #$*% String.prototype.search (RegExp):index, RegExp 在字符串中首次匹配项的索引  返回首次匹配项的索引，未匹配则返回 -1 类似于正则表达式的test():Boolean方法,'ssass'.indexOf('a')方法; 当要了解更多匹配信息时，可使用 match()方法  1var str = \u0026#34;hey JudE\u0026#34;; 2var re = /[A-Z]/g; 3var re2 = /[.]/g; 4console.log(str.search(re)); // returns 4, which is the index of the first capital letter \u0026#34;J\u0026#34; 5console.log(str.search(re2)); // returns -1 cannot find \u0026#39;.\u0026#39; dot punctuation String.prototype.split ([separator[, limit]] ):Array, 用 separator 把字符串分割成数组  separator 可以是一个字符串或正则表达式  1var myString = \u0026#34;Hello 1 word. Sentence number 2.\u0026#34;; 2var splits = myString.split(/(\\d)/); 3//[ \u0026#34;Hello \u0026#34;, \u0026#34;1\u0026#34;, \u0026#34; word. Sentence number \u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;.\u0026#34; ] 4console.log(splits);  separator如果是数组会转化为字符串  1const myString = \u0026#39;ca,bc,a,bca,bca,bc\u0026#39;; 2 3const splits = myString.split([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;]); 4// myString.split([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;]) is same as myString.split(String([\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;])) 5 6console.log(splits); //[\u0026#34;c\u0026#34;, \u0026#34;c,\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;c\u0026#34;]  limit 为一个整数，限定返回的分割片段数量  1var myString = \u0026#34;Hello World. How are you doing?\u0026#34;; 2var splits = myString.split(\u0026#34; \u0026#34;, 3); 3//[\u0026#39;Hello\u0026#39;, \u0026#39;World.\u0026#39;, \u0026#39;How\u0026#39;] 4console.log(splits); ","date":"2021-12-26","img":"","permalink":"/posts/regexpfunc/","series":["javascript"],"tags":["replace","exec","test","match","search","split"],"title":"使用正则的场景"},{"categories":["前端"],"content":"1.前端基础知识看下面 3 个网站就够了，不需要东看看西看看。  w3c  MDN  freecodecamp   2.技能点查漏补缺(主要来源于附件图) internet  How does the internet work ? What is HTTP?  Browsers and how they work ? DNS and how it works? What is Domain Name ? What is hosting ?  HTML  Learn the basics Writing Semantic HTML Forms and Validations Conventions and Best Practices SEO Basics Accessibility  css  Learn the basics Making Layouts (Floats, Positioning, Display, Box Model, CSS Grid, Flex Box) Responsive design and Media Queries sass  BEM  Styled Component CSS Modules  icons  iconfont Sketch  PhotoShop   JavaScript  Syntax and Basic Construct Learn DOM Manipulation  Learn FetchAPI /Ajax(XHR)  ES6+ and modular JavaScript  Understand the conceptsHoisting ，EventBubbling，Scope，Prototype ，ShadowDOM，strict  Version Control Systems  Basic Usage of Git  github gitlab  Web Security Knowledge  HTTPS Content Security Policy CORS OWASP Security Risks  Package Managers  npm  cnpm  Build Tools  Task Runners(npm scripts) Module Bundlers(webpack ) Linters and For matters(ESLint ,Prettier )  Pick a Framework  Vue (vuex ,vue-router ,axios ,element-ui ) React (Redux ,Reactstrap ,Material UI,Bootstrap)  Web Components  HTML Templates Custom Elements Shadow DOM   Testing your Apps  Jest   Type Checkers  TypeScript   Progressive Web Apps  Storage Web Sockets  Service Workers  PRPL Pattern RAIL Model Performance Metrics Using Lighthouse  ServerSide Rendering (SSR)  React(Next.js)  Vue(Nuxt.js)   GraphQL  Apollo   Static Site Generators  Next.js GatsbyJS Hugo  Jekyll Nuxt.js  Mobile Applications  React Native   Desktop Applictions  Electron   Web Assembly(WASM)  Go   开发工具  vscode  Fiddler 或 Charles Postman Chrome DevTools   自制工具  创建项目 cli 工具  可视化  SVG  D3  Raphaël  Snap    Canvas 2D  Echarts  HighCharts    WebGL  Three     微前端  qiankun  single-spa   设计模式  单例模式  工厂模式  观察者模式  发布订阅模式  代理模式  适配器模式  策略模式  命令模式   数据结构  堆（Heap） 栈（Stack） 队列（Queue） 链表（Linked List） 数组（Array） 树（Tree） 集合（Set） 哈希表（Map）  算法  排序  冒泡排序 选择排序 插入排序 快速排序 希尔排序 归并排序 堆排序 计数排序 基数排序   检索  线性搜索 二分查找 索引 深度优先搜索（DFS） 广度优先搜索（BFS）   Diff  JavaScript 算法与数据结构   计算机网络  OSI 七层模型   后端扩展  nodejs   3.经常上github 查看前端开源库源码，是快速提高技能的重要方式  \u0026mdash;附件图片\u0026mdash;\n","date":"2021-12-20","img":"","permalink":"/posts/guide/","series":["规划"],"tags":["技能点"],"title":"前端学习路线图"},{"categories":["爬山"],"content":"2021 年 12 月 19 日在两步路 App，报名参加了阳台山大环户外，全程有 42.43 公里，最高海拔 569 米，累计爬升 3099 米，天生牛犊不怕虎，初生新驴不怕虐，带着减肥的目标报名了\n有个热心队友，自掏腰包 1800，设立了爬山的奖金，男女各组 1-3 名奖励 200，男子 4-10 名奖励 100(女生少，只设 3 个奖)，这个热心队友是真的热心，一大早就煮了很多鸡腿带过来给大家吃，出钱又出东西，真的没话说。\n6 点半起床，楼下吃完热干面就急匆匆的打车前往阳台山胜利大营救，一到就傻眼了，全都是瘦瘦的肌肉猛男猛女，装备一看就是专业的队伍，听说很多都是户外运动比赛的冠军，7 点 35 爬山开始。\n这个爬山路径很变态，八上八下，好不容易爬到山顶又下来，然后又爬到山顶，走完了 8 条上山下山路径，上山路都是选择的最陡的，对身体素质考验很大\n一开始跟着队伍跑了一两公里，体力就有点不支了(平常运动太少了)，右腿也有点抽筋了，一瘸一拐的坚持到了应人石，到应人石已经 1 点多了，腿实在受不了，就下撤了，爬了 18 公里多。\n完赛的大神成绩汇总单\n女大神上坡都是跑的，好厉害\nYour browser does not support the video tag.  通过这次户外，认识到了运动需要一步步提升，强来容易带来身体上的伤害，需要先找难度低一点的，等体能提升了再慢慢挑战难一点的运动。\n","date":"2021-12-19","img":"","permalink":"/posts/sport20211219/","series":["游记"],"tags":["阳台山"],"title":"羊台山大环徒步"},{"categories":["编码"],"content":"When you have some binary data that you want to ship across a network, you generally don\u0026rsquo;t do it by just streaming the bits and bytes over the wire in a raw format. Why? because some media are made for streaming text. You never know \u0026ndash; some protocols may interpret your binary data as control characters (like a modem), or your binary data could be screwed up because the underlying protocol might think that you\u0026rsquo;ve entered a special character combination (like how FTP translates line endings). So to get around this, people encode the binary data into characters. Base64 is one of these types of encodings. Why 64? Because you can generally rely on the same 64 characters being present in many character sets, and you can be reasonably confident that your data\u0026rsquo;s going to end up on the other side of the wire uncorrupted\n标准 ASCII 码，使用 7 位二进制数 2（2^7=128,剩下的 1 位二进制为 0）来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符，码表如下\nbase64 使用大写和小写字母，数字 0 到 9，+ /共 64 个字符编码，码表如下\n那么怎么将 ascii 字符\u0026rsquo;ab',转化为 base64 码，规则是怎么样的呢？\n我们在 ascii 码表分别找到 a，b 的码值为 97,98，用 2 进制表示为 1100001，1100010(可以使用方法 97..toString(2)得到)，不足 8 位的在前面补 0，那么‘ab’二进制表示就是 01100001 01100010\nbase64 只有 64 个字符，只需要 6（2^6=64）位就可以容纳，那么我们可以分割成 011000 010110 0010，① 后面不足 6 位在后面补 0，于是就成为了 011000 010110 001000，我们得出他们的 10 进制分别为 24,22,8（可以使用 parseInt(11000,2)计算出）\n通过比对 base64 码，我们分别找到 24,22,8 对应的字符为 Y,W,I\n根据规定转化后的长度需要是 4 的倍数，② 不足部分在后面加‘=’，于是变成了 YWI=,我们通过 btoa(\u0026lsquo;ab\u0026rsquo;)方法验证，结果正确\nab 字符实际有效占用的空间是 27=14 位（标准的 ascii 只有 7 位有效的)，转化为 base64 后，48=32 位（这里加了个=，多了 8 位），因此 base64 编码后会增加传输量，具体增加多少取决于 ① ② 处\n","date":"2021-12-16","img":"","permalink":"/posts/ascii2base64/","series":["原理"],"tags":["base64","ascii"],"title":"Ascii转base64"},{"categories":["部署"],"content":"前言 同事问我，你有什么梦想，我想了半天没有回答出来，思来想去，对于梦想，大多数都跟钱有关，话说没有钱解决不了的问题，解决不了那就是钱不够，那么我们有没有什么东西是很重要，又是钱买不到的，或者不容易买到的呢\n健康的身体，话说身体是革命的本钱，是所有的基础，花时间去锻炼身体，健康营养的饮食，良好愉悦的心情，是保持健康的最低条件\n一技之长，人生的价值在于被利用价值，人不可能做好很多事，于是根据自己能力选择合适的事就很重要，做一行爱一行，拥有难以替代的特长，是生存的保障\n对于未来的希望，未来很漫长，需要有期待，有诗，有远方\n能够陪伴你的好友，人是群体动物，社会关系构筑了现代文明体系，每个人都很忙，在快节奏的城市，能够有交集那也是难得的缘分\n2022 决定好好写博客，促使自己学习，变的更好(这也是建站目的)\n域名申请 域名我使用的阿里云的万网 购买的 10 年期限，199 人民币，也可以不买域名，买域名只是让网站地址更加好记忆，看起来高大上一点，免费静态托管网站提供的地址太长不友好\n域名买下来后需要在购买商那里完成实名信息登记\nicp 备案与免费静态服务器 根据国家规定，国内的网站都需要备案，备案就是企业或个人提交建站相关信息到对应服务商，用于国家监管，服务器在国外就不需要备案\n找到的免费的静态托管网站有 gitee 和 github，gitee 在国内需要备案，不提供个性化域名服务(收费版本可以)，但是访问速度会快于 github，为了使用个性化域名，所以我选择了 github\nhugo 工程创建与编译  下载 hugo 软件 生成网站 将解压的可执行文件路径 bin 目录加入环境变量 path 新开 cmd 命令窗口，创建工程  1hugo new site myblog 2cd myblog 3新建目录themes 将hugo-theme-bootstrap 下载下来放在 themes 目录下 在 myblog 工程根目录下执行下列命令  1cp -a themes/hugo-theme-bootstrap/exampleSite/* . 2//如果你使用的是 Windows，请改用 xcopy .\\themes\\hugo-theme-bootstrap\\exampleSite /E 运行工程 hugo server --watch 编译文件到 docs 目录下 hugo -d docs 将整个工程提交到 github 仓库中  域名解析与 github page 设置  在域名服务商将域名 CNAME 到 github 服务器，格式为 github 用户名.github.io（@记录为不带 www 的域名解析）  点开刚刚提交到的 github 仓库，进入 settings 目录 找到 GitHub Pages,点击 Check it out here 填写代码所在分支，选择/docs 目录，点保存，Custom domain 填写自己刚刚解析的域名地址，点保存   我们可以用 github Actions 自动构建，来优化流程，这样每次 commit，就会自动编译，部署  配置 settings pages 项,部署分支改为 gh-pages,目录选择/root,工作流编译的代码会放在这里 配置 Actions 项，点击最上面的set up a workflow yourself， 将下面的工作流代码复制进.github/workflows/你的分支名.yml，然后 start commit  1# This is a basic workflow to help you get started with Actions 2name: CI 3# Controls when the workflow will run 4 5on: 6# Triggers the workflow on push or pull request events but only for the main branch 7push: 8branches: [main] 9pull_request: 10branches: [main] 11# Allows you to run this workflow manually from the Actions tab 12workflow_dispatch: 13# A workflow run is made up of one or more jobs that can run sequentially or in parallel 14jobs: 15# This workflow contains a single job called \u0026#34;build\u0026#34; 16build: # The type of runner that the job will run on 17runs-on: ubuntu-latest 18 # Steps represent a sequence of tasks that will be executed as part of the job 19 steps: 20 # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it 21 - uses: actions/checkout@v2 22 23 # Runs a single command using the runners shell 24 - name: Run a one-line script 25 run: echo Hello, world! 26 27 - name: Setup Hugo 28 uses: peaceiris/actions-hugo@v2 29 with: 30 hugo-version: \u0026#34;0.90.1\u0026#34; 31 # extended: true 32 33 - name: Build 34 run: hugo -d docs 35 36 # 将main分支打包后的docs文件夹内容放到gh-pages分支上 37 - name: Deploy 38 uses: peaceiris/actions-gh-pages@v3 39 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} 40 with: 41 github_token: ${{ secrets.GITHUB_TOKEN }} 42 publish_dir: ./docs 提交代码后，再次进入 Actions,你就可以看到 workflows 运行情况，点击具体的任务，可以重新跑这个任务，查看 workflow 具体的执行步骤 ","date":"2021-12-15","img":"","permalink":"/posts/buildwebsite/","series":["工具"],"tags":["hugo","hugo-theme-bootstrap","github page"],"title":"使用hugo搭建博客"},{"categories":["版本管理工具"],"content":"git 命令 代码拉取  git 配置用户名邮箱 $ git config --global user.name \u0026quot;John Doe\u0026quot; $ git config --global user.email johndoe@example.com 克隆仓库 $ git clone git://github.com/schacon/ticgit.git git clone 只能 clone 远程库的 master 分支，无法 clone 所有分支  branch 操作  创建分支 git branch 分支名; 切换分支 git checkout 分支名， 创建分支并切换到对应分支git checkout -b 分支名 [origin/branchName] 删除本地某分支 git branch -d 分支名 查看本地分支情况 git branch 查看远程分支 git branch -r 分支重命名 git branch -m oldname newname 将 test 分支合并进当前分支 git merge test  tag 操作  查看 git tag 给当前 commit 添加 tag git tag -a tagname -m \u0026quot;comment\u0026quot; or git tag tagname 删除 tag git tag -d tagname 提交 tag git push origin tagname or once push all git push origin --tags  代码状态  显示有变更的文件 git status  显示当前分支的版本历史 git log [--pretty=oneline] 显示历史操作记录 git reflog 查看修改情况 git diff   代码还原  语法 git reset －－[mixed 默认|hard|soft] commit 号|HEAD~n|HEAD^^^|HEAD^ hard－\u0026gt;add 之前文件也还原(回到 1) mixed－\u0026gt;add 之前(回到 2) soft－\u0026gt;commit 之前，保留 add(回到 3) \u0026lt;\u0026ndash;1-modify\u0026ndash;2\u0026ndash;add\u0026ndash;3\u0026ndash;commit\u0026ndash;4\u0026ndash;\u0026gt; 优先级为:从暂存区,当前最后一次 commit,拿此文件替换工作区此文件 git checkout --文件名  提交代码  git add [file|.|-A]  git commit -a --amend (修改上一次 commit 信息) git commit -m “注释” (添加本次 commit 的注释) 更新远程代码  git pull origin branchname 提交代码 git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; or samename git push origin branchname (在解决完冲突后，重新 add commit push）  gitlab 配置  打开 git bash 窗口 查看是否已经存在 SSH key pair cat ~/.ssh/id_rsa.pub 存在就跳过生成步骤 4 生成 ssh key 命令： ssh-keygen -t rsa -C \u0026ldquo;your email address\u0026rdquo; ssh 公钥 id_rsa.pub 拷贝到 gitlab\u0026rsquo;右上角\u0026gt;头像\u0026gt;设置\u0026gt;ssh 密钥' 官方相关说明   github 配置  github 配置类似 gitlab 配置 ssh 公钥 id_rsa.pub 可以共用，不需要重新生成(哪怕 your email address 不一样也可以) 通信凭证在 2021.8 月禁用了 account passwords 方式 默认方式由 ssh 变为了 https token ，代码仓库地址默认是 https 而不再是 ssh  按照原来 ssh 配置后，执行ssh -T git@github.com 提示 You\u0026rsquo;ve successfully authenticated 则凭证正确 复制 ssh 地址， git clone 代码(注意要选择 ssh 地址，因为配置的凭证是 ssh 的),或者用 https 地址，配置新的 https token 认证方式  tapd 与 gitlab 关联  tapd 文档相关说明  ","date":"2021-12-15","img":"","permalink":"/posts/git/","series":["工具"],"tags":["git","gitlab","tapd","github"],"title":"Git相关使用"},{"categories":null,"content":" 主要用于书写前端技术博客和记录生活点滴 本博客代码托管于 github page 使用了 hugo-theme-bootstrap 博客主题 爱前端(iqianduan)首次部署于 2021-12-14  ","date":"2019-02-28","img":"","permalink":"/about/","series":null,"tags":null,"title":"关于"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/faq/","series":null,"tags":null,"title":"Frequently Asked Questions"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/offline/","series":null,"tags":null,"title":"Offline"},{"categories":null,"content":"","date":"0001-01-01","img":"","permalink":"/contact/","series":null,"tags":null,"title":"联系我们"}]